package.preload['drivers-common-public.global.handlers'] = (function (...)
-- Copyright 2022 Snap One, LLC. All rights reserved.

Metrics = require ('drivers-common-public.module.metrics')
require ('drivers-common-public.global.lib')

COMMON_HANDLERS_VER = 17

do -- define globals
	DEBUG_RFN = false
end

--[[
	Inbound Driver Functions:
		-- ExecuteCommand (strCommand, tParams)
		FinishedWithNotificationAttachment ()
		GetNotificationAttachmentURL ()
		GetNotificationAttachmentFile ()
		GetNotificationAttachmentBytes ()
		GetPrivateKeyPassword (idBinding, nPort)
		ListEvent (strEvent, param1, param2)
		ListMIBReceived (strCommand, nCount, tParams)
		ListNewControl (strContainer, strNavID, idDevice, tParams)
		ListNewList (nListID, nItemCount, strName, nIndex, strContainer, strCategory, strNavID)
		--OnBindingChanged (idBinding, strClass, bIsBound, otherDeviceID, otherBindngID)
		--OnConnectionStatusChanged (idBinding, nPort, strStatus)
		OnDriverDestroyed () -- in MSP
		OnDriverInit ()		 -- in MSP
		OnDriverLateInit ()	 -- in MSP
		OnDriverRemovedFromProject ()
		--OnDeviceEvent (firingDeviceId, eventId)
		OnNetworkBindingChanged (idBinding, bIsBound)
		OnPoll (idBinding, bIsBound)
		-- OnPropertyChanged (strProperty)
		OnReflashLockGranted ()
		OnReflashLockRevoked ()
		OnServerConnectionStatusChanged (nHandle, nPort, strStatus)
		OnServerDataIn (nHandle, strData, strclientAddress, strPort)
		OnServerStatusChanged (nPort, strStatus)
		-- OnSystemEvent (event)
		OnTimerExpired (idTimer)
		-- OnVariableChanged (strVariable)
		-- OnWatchedVariableChanged (idDevice, idVariable, strValue)
		OnZigbeeOnlineStatusChanged (strStatus, strVersion, strSkew)
		OnZigbeePacketIn (strPacket, nProfileID, nClusterID, nGroupID, nSourceEndpoint, nDestinationEndpoint)
		OnZigbeePacketFailed (strPacket, nProfileID, nClusterID, nGroupID, nSourceEndpoint, nDestinationEndpoint)
		OnZigbeePacketSuccess (strPacket, nProfileID, nClusterID, nGroupID, nSourceEndpoint, nDestinationEndpoint)
		-- ReceivedAsync (ticketId, strData, responseCode, tHeaders, strError)
		-- ReceivedFromNetwork (idBinding, nPort, strData)
		-- ReceivedFromProxy (idBinding, strCommand, tParams)
		ReceivedFromSerial (idBinding, strData)
		--TestCondition (strConditionName, tParams)
		--UIRequest (strCommand, tParams)


		DoPersistSave ()
		SetProperty ()
		SetGlobal ()

		OnBindingValidate (idBinding, strClass)

		OnUsbSerialDeviceOnline (idDevice, strManufacturer, strProduct, strSerialNum, strHostname, nFirstPort, nNumPorts)
		OnUsbSerialDeviceOffline ()

		Attach ()
		OnEndDebugSession ()

]]

--[[
	C4 System Events (from C4SystemEvents global) - valid values for OSE keys
	1	OnAll
	2	OnAlive
	3	OnProjectChanged
	4	OnProjectNew
	5	OnProjectLoaded
	6	OnPIP
	7	OnItemAdded
	8	OnItemNameChanged
	9	OnItemDataChanged
	10	OnDeviceDataChanged
	11	OnItemRemoved
	12	OnItemMoved
	13	OnDriverAdded
	14	OnDeviceIdentified
	15	OnBindingAdded
	16	OnBindingRemoved
	17	OnNetworkBindingAdded
	18	OnNetworkBindingRemoved
	19	OnNetworkBindingRegistered
	20	OnNetworkBindingUnregistered
	21	OnCodeItemAdded
	22	OnCodeItemRemoved
	23	OnCodeItemMoved
	24	OnMediaInfoAdded
	25	OnMediaInfoModified
	26	OnMediaRemovedFromDevice
	27	OnMediaDataRemoved
	28	OnSongAddedToPlaylist
	29	OnSongRemovedFromPlaylist
	30	OnPhysicalDeviceAdded
	31	OnPhysicalDeviceRemoved
	32	OnDataToUI
	33	OnAccessModeChanged
	34	OnVariableAdded
	35	OnUserVariableAdded
	36	OnVariableRemoved
	37	OnVariableRenamed
	38	OnVariableChanged
	39	OnVariableBindingAdded
	40	OnVariableBindingRemoved
	41	OnVariableBindingRenamed
	42	OnVariableAddedToBinding
	43	OnVariableRemovedFromBinding
	44	OnMediaDeviceAdded
	45	OnMediaDeviceRemoved
	46	OnProjectLocked
	47	OnProjectLeaveLock
	48	OnDeviceOnline
	49	OnDeviceOffline
	50	OnSearchTypeFound
	51	OnNetworkBindingStatusChanged
	52	OnZipcodeChanged
	53	OnLatitudeChanged
	54	OnLongitudeChanged
	55	OnDeviceAlreadyIdentified
	56	OnControllerDisabled
	57	OnDeviceFirmwareChanged
	58	OnLocaleChanged
	59	OnZigbeeNodesChanged
	60	OnZigbeeZapsChanged
	61	OnZigbeeMeshChanged
	62	OnZigbeeZserverChanged
	63	OnSysmanResponse
	64	OnTimezoneChanged
	65	OnMediaSessionAdded
	66	OnMediaSessionRemoved
	67	OnMediaSessionChanged
	68	OnMediaDeviceChanged
	69	OnProjectEnterLock
	70	OnDeviceIdentifiedNoLicense
	71	OnZigBeeStickPresent
	72	OnZigBeeStickRemoved
	73	OnZigbeeNodeUpdateStatus
	74	OnZigbeeNodeUpdateSucceeded
	75	OnZigbeeNodeUpdateFailed
	76	OnZigbeeNodeOnline
	77	OnZigbeeNodeOffline
	78	OnSDDPDeviceStatus
	79	OnSDDPDeviceDiscover
	80	OnAccountInfoUpdated
	81	OnAccountInfoUpdating
	82	OnBindingEntryAdded
	83	OnBindingEntryRemoved
	84	OnProjectClear
	85	OnSystemShutDown
	86	OnSystemUpdateStarted
	87	OnDevicePreIdentify
	88	OnDeviceIdentifying
	89	OnDeviceCancelIdentify
	90	OnDirectorIPAddressChanged
	91	OnDeviceDiscovered
	92	OnDeviceUserInitiatedRemove
	93	OnDriverDisabled
	94	OnDiscoveredDeviceAdded
	95	OnDiscoveredDeviceRemoved
	96	OnDiscoveredDeviceChanged
	97	OnDeviceIPAddressChanged
	98	OnCIDRRulesChanged
	99	OnBindingEntryRenamed
	100	OnCodeItemEnabled
	101	OnCodeItemCommandUpdated
	102	OnSystemUpdateFinished
	103	OnTimeChanged
	104	OnMediaSessionDiscreteMuteChanged
	105	OnMediaSessionMuteStateChanged
	106	OnMediaSessionDiscreteVolumeChanged
	107	OnMediaSessionVolumeLevelChanged
	108	OnMediaSessionMediaInfoChanged
	109	OnMediaSessionVolumeSliderStateChanged
	110	OnScheduledEvent
	111	OnMediaSessionSliderTargetVolumeReached
	112	OnCodeItemAddedToExpression
	113	OnProjectPropertyChanged
	114	OnEventAdded
	115	OnEventModified
	116	OnEventRemoved
	117	OnZigbeeNetworkHealth
]]

do	--Globals
	EC = EC or {}
	OBC = OBC or {}
	ODE = ODE or {}
	OCS = OCS or {}
	OPC = OPC or {}
	OSE = OSE or {}
	OVC = OVC or {}
	OWVC = OWVC or {}
	RFN = RFN or {}
	RFP = RFP or {}
	TC = TC or {}
	UIR = UIR or {}
end

do	--Setup Metrics
	MetricsHandler = Metrics:new ('dcp_handler', COMMON_HANDLERS_VER)
end

function HandlerDebug (init, tParams, args)
	if (not DEBUGPRINT) then
		return
	end

	if (type (init) ~= 'table') then
		return
	end

	local output = init

	if (type (tParams) == 'table' and next (tParams) ~= nil) then
		table.insert (output, '----PARAMS----')
		for k, v in pairs (tParams) do
			local line = tostring (k) .. ' = ' .. tostring (v)
			table.insert (output, line)
		end
	end

	if (type (args) == 'table' and next (args) ~= nil) then
		table.insert (output, '----ARGS----')
		for k, v in pairs (args) do
			local line = tostring (k) .. ' = ' .. tostring (v)
			table.insert (output, line)
		end
	end

	local t, ms
	if (C4.GetTime) then
		t = C4:GetTime ()
		ms = '.' .. tostring (t % 1000)
		t = math.floor (t / 1000)
	else
		t = os.time ()
		ms = ''
	end
	local s = os.date ('%x %X') .. ms

	table.insert (output, 1, '-->  ' .. s)
	table.insert (output, '<--')
	output = table.concat (output, '\r\n')
	print (output)
	C4:DebugLog (output)
end

function ExecuteCommand (strCommand, tParams)
	tParams = tParams or {}
	local init = {
		'ExecuteCommand: ' .. strCommand,
	}
	HandlerDebug (init, tParams)

	if (strCommand == 'LUA_ACTION') then
		if (tParams.ACTION) then
			strCommand = tParams.ACTION
			tParams.ACTION = nil
		end
	end

	strCommand = string.gsub (strCommand, '%s+', '_')

	local success, ret

	if (EC and EC [strCommand] and type (EC [strCommand]) == 'function') then
		success, ret = pcall (EC [strCommand], tParams)
	end

	if (success == true) then
		return (ret)
	elseif (success == false) then
		MetricsHandler:SetCounter ('Error_ExecuteCommand')
		print ('ExecuteCommand error: ', ret, strCommand)
	end
end

function OnBindingChanged (idBinding, strClass, bIsBound, otherDeviceId, otherBindingId)
	local init = {
		'OnBindingChanged: ' .. idBinding,
	}
	local tParams = {
		strClass = strClass,
		bIsBound = tostring (bIsBound),
		otherDeviceId = otherDeviceId,
		otherBindingId = otherBindingId,
	}
	HandlerDebug (init, tParams)

	local success, ret

	if (OBC and OBC [idBinding] and type (OBC [idBinding]) == 'function') then
		success, ret = pcall (OBC [idBinding], idBinding, strClass, bIsBound, otherDeviceId, otherBindingId)
	end

	if (success == true) then
		return (ret)
	elseif (success == false) then
		MetricsHandler:SetCounter ('Error_OnBindingChanged')
		print ('OnBindingChanged error: ', ret, idBinding, strClass, bIsBound, otherDeviceId, otherBindingId)
	end

end

function OnConnectionStatusChanged (idBinding, nPort, strStatus)
	local init = {
		'OnConnectionStatusChanged: ' .. idBinding
	}
	local tParams = {
		nPort = nPort,
		strStatus = strStatus,
	}
	HandlerDebug (init, tParams)

	local success, ret

	if (OCS and OCS [idBinding] and type (OCS [idBinding]) == 'function') then
		success, ret = pcall (OCS [idBinding], idBinding, nPort, strStatus)
	end

	if (success == true) then
		return (ret)
	elseif (success == false) then
		MetricsHandler:SetCounter ('Error_OnConnectionStatusChanged')
		print ('OnConnectionStatusChanged error: ', ret, idBinding, nPort, strStatus)
	end
end

function RegisterDeviceEvent (firingDeviceId, eventId, callback)
	if (firingDeviceId == nil or eventId == nil) then
		MetricsHandler:SetCounter ('Error_RegisterDeviceEvent')
		print ('RegisterDeviceEvent error (Invalid idDevice / idVariable): ', tostring(firingDeviceId), tostring(eventId), tostring(callback))
		return
	end

	C4:UnregisterDeviceEvent (firingDeviceId, eventId)

	ODE [firingDeviceId] = ODE [firingDeviceId] or {}

	if (type (callback) == 'function') then
		ODE [firingDeviceId] [eventId] = callback
		C4:RegisterDeviceEvent (firingDeviceId, eventId)
	else
		MetricsHandler:SetCounter ('Error_RegisterDeviceEvent')
		print ('RegisterDeviceEvent error (callback not a function): ', firingDeviceId, eventId, callback)
	end
end

function UnregisterDeviceEvent (firingDeviceId, eventId)
	if (firingDeviceId == nil or eventId == nil) then
		MetricsHandler:SetCounter ('Error_UnregisterDeviceEvent')
		print ('UnregisterDeviceEvent error (Invalid idDevice / idVariable): ', tostring(firingDeviceId), tostring(eventId))
		return
	end

	if (ODE and ODE [firingDeviceId]) then
		ODE [firingDeviceId] [eventId] = nil
	end

	C4:UnregisterDeviceEvent (firingDeviceId, eventId)
end

function OnDeviceEvent (firingDeviceId, eventId)
	local init = {
		'OnDeviceEvent: ' .. C4:GetDeviceDisplayName (firingDeviceId) .. ' [' .. firingDeviceId .. ']',
		eventId,
	}
	HandlerDebug (init)

	local success, ret

	if (ODE and ODE [firingDeviceId] and ODE [firingDeviceId] [eventId] and type (ODE [firingDeviceId] [eventId]) == 'function') then
		success, ret = pcall (ODE [firingDeviceId] [eventId], firingDeviceId, eventId)
	end

	if (success == true) then
		return (ret)
	elseif (success == false) then
		MetricsHandler:SetCounter ('Error_OnDeviceEvent')
		print ('OnDeviceEvent error: ', ret, firingDeviceId, eventId)
	end
end

function UpdateProperty (strProperty, strValue, notifyChange)
	if (type (strProperty) ~= 'string') then
		MetricsHandler:SetCounter ('Error_UpdateProperty')
		print ('UpdateProperty error (strProperty not string): ', tostring(strProperty), tostring(strValue))
		return
	end

	if (type (strValue) ~= 'string') then
		MetricsHandler:SetCounter ('Error_UpdateProperty')
		print ('UpdateProperty error (strValue not string): ', tostring(strProperty), tostring(strValue))
		return
	end

	if (Properties [strProperty] == nil) then
		MetricsHandler:SetCounter ('Error_UpdateProperty')
		print ('UpdateProperty error (Property not present in Properties table): ', tostring(strProperty), tostring(strValue))
		return
	end

	if (Properties [strProperty] ~= strValue) then
		C4:UpdateProperty (strProperty, strValue)
	end
	if (notifyChange == true) then
		OnPropertyChanged (strProperty)
	end
end

function OnPropertyChanged (strProperty)
	local value = Properties [strProperty]
	if (type (value) ~= 'string') then
		value = ''
	end

	local init = {
		'OnPropertyChanged: ' .. strProperty,
		value,
	}
	HandlerDebug (init)

	strProperty = string.gsub (strProperty, '%s+', '_')

	local success, ret

	if (OPC and OPC [strProperty] and type (OPC [strProperty]) == 'function') then
		success, ret = pcall (OPC [strProperty], value)
	end

	if (success == true) then
		return (ret)
	elseif (success == false) then
		MetricsHandler:SetCounter ('Error_OnPropertyChanged')
		print ('OnPropertyChanged error: ', ret, strProperty, value)
	end
end

function OnSystemEvent (event)
	local eventName = string.match (event, '.-name="(.-)"')

	local init = {
		'OnSystemEvent: ' .. eventName,
		event,
	}
	HandlerDebug (init)

	local success, ret

	if (OSE) then
		eventName = string.gsub (eventName, '%s+', '_')
		if (OSE [eventName] and type (OSE [eventName]) == 'function') then
			success, ret = pcall (OSE [eventName], event)
		end
	end

	if (success == true) then
		return (ret)
	elseif (success == false) then
		MetricsHandler:SetCounter ('Error_OnSystemEvent')
		print ('OnSystemEvent error: ', ret, eventName, event)
	end
end

function SetVariable (strVariable, strValue, notifyChange)
	if (strVariable == nil or strValue == nil) then
		MetricsHandler:SetCounter ('Error_SetVariable')
		print ('SetVariable error (Invalid strVariable / strValue): ', tostring(strVariable), tostring(strValue))
		return
	end

	C4:SetVariable (strVariable, strValue)
	if (notifyChange == true) then
		OnVariableChanged (strVariable)
	end
end

function OnVariableChanged (strVariable)
	local value = Variables [strVariable]
	if (value == nil) then
		value = ''
	end

	local init = {
		'OnVariableChanged: ' .. strVariable,
		value,
	}
	HandlerDebug (init)

	strVariable = string.gsub (strVariable, '%s+', '_')

	local success, ret

	if (OVC and OVC [strVariable] and type (OVC [strVariable]) == 'function') then
		success, ret = pcall (OVC [strVariable], value)
	end

	if (success == true) then
		return (ret)
	elseif (success == false) then
		MetricsHandler:SetCounter ('Error_OnVariableChanged')
		print ('OnVariableChanged error: ', ret, strVariable, value)
	end
end

function RegisterVariableListener (idDevice, idVariable, callback)
	if (idDevice == nil or idVariable == nil) then
		MetricsHandler:SetCounter ('Error_RegisterVariableListener')
		print ('RegisterVariableListener error (Invalid idDevice / idVariable): ', tostring(idDevice), tostring(idVariable), tostring(callback))
		return
	end

	C4:UnregisterVariableListener (idDevice, idVariable)

	OWVC [idDevice] = OWVC [idDevice] or {}

	if (type (callback) == 'function') then
		OWVC [idDevice] [idVariable] = callback
		C4:RegisterVariableListener (idDevice, idVariable)
	else
		MetricsHandler:SetCounter ('Error_RegisterVariableListener')
		print ('RegisterVariableListener error (callback not a function): ', idDevice, idVariable, callback)
	end
end

function UnregisterVariableListener (idDevice, idVariable)
	if (idDevice == nil or idVariable == nil) then
		MetricsHandler:SetCounter ('Error_UnregisterVariableListener')
		print ('UnregisterVariableListener error (Invalid idDevice / idVariable): ', tostring(idDevice), tostring(idVariable))
		return
	end

	if (OWVC and OWVC [idDevice]) then
		OWVC [idDevice] [idVariable] = nil
	end

	C4:UnregisterVariableListener (idDevice, idVariable)
end

function OnWatchedVariableChanged (idDevice, idVariable, strValue)
	local init = {
		'OnWatchedVariableChanged: ' .. C4:GetDeviceDisplayName (idDevice) .. ' [' .. idDevice .. ']',
	}
	local varName = Select (C4:GetDeviceVariables (idDevice), tostring (idVariable), 'name') or ''
	varName = varName .. ' [' .. idVariable .. ']'

	local tParams = {
		[varName] = strValue,
	}
	HandlerDebug (init, tParams)

	local success, ret

	if (OWVC and
			OWVC [idDevice] and
			OWVC [idDevice] [idVariable] and
			type (OWVC [idDevice] [idVariable]) == 'function') then
		success, ret = pcall (OWVC [idDevice] [idVariable], idDevice, idVariable, strValue)
	else
		success = false
		ret = 'Callback not available for registered variable'
	end

	if (success == true) then
		return (ret)
	elseif (success == false) then
		MetricsHandler:SetCounter ('Error_OnWatchedVariableChanged')
		print ('OnWatchedVariableChanged error: ', ret, idDevice, idVariable, strValue)
	end
end

function ReceivedFromNetwork (idBinding, nPort, strData)
	local suppressRFN

	if (WebSocket) then
		if (WebSocket.Sockets and WebSocket.Sockets [idBinding]) then
			suppressRFN = not (DEBUG_RFN or DEBUG_WEBSOCKET)
		end
	end

	if (SSDP) then
		if (SSDP.SearchTargets and SSDP.SearchTargets [idBinding]) then
			suppressRFN = not (DEBUG_RFN)
		end
	end

	if (not suppressRFN) then
		local init = {
			'ReceivedFromNetwork: ' .. idBinding,
		}
		local tParams = {
			nPort = nPort,
			dataLen = #strData,
			data = (DEBUG_RFN and strData) or nil,
		}
		HandlerDebug (init, tParams)
	end

	local success, ret

	if (RFN and RFN [idBinding] and type (RFN [idBinding]) == 'function') then
		success, ret = pcall (RFN [idBinding], idBinding, nPort, strData)
	end

	if (success == true) then
		return (ret)
	elseif (success == false) then
		MetricsHandler:SetCounter ('Error_ReceivedFromNetwork')
		print ('ReceivedFromNetwork error: ', ret, idBinding, nPort, strData)
	end
end

function ReceivedFromProxy (idBinding, strCommand, tParams)
	strCommand = strCommand or ''
	tParams = tParams or {}
	local args = {}
	if (tParams.ARGS) then
		local parsedArgs = C4:ParseXml (tParams.ARGS)
		for _, v in pairs (parsedArgs.ChildNodes) do
			args [v.Attributes.name] = v.Value
		end
		tParams.ARGS = nil
	end

	local init = {
		'ReceivedFromProxy: ' .. idBinding,
		strCommand,
	}
	HandlerDebug (init, tParams, args)

	local success, ret

	if (RFP and RFP [strCommand] and type (RFP [strCommand]) == 'function') then
		success, ret = pcall (RFP [strCommand], idBinding, strCommand, tParams, args)

	elseif (RFP and RFP [idBinding] and type (RFP [idBinding]) == 'function') then
		success, ret = pcall (RFP [idBinding], idBinding, strCommand, tParams, args)
	end

	if (success == true) then
		return (ret)
	elseif (success == false) then
		MetricsHandler:SetCounter ('Error_ReceivedFromProxy')
		print ('ReceivedFromProxy error: ', ret, idBinding, strCommand)
	end
end

function TestCondition (strConditionName, tParams)
	strConditionName = strConditionName or ''
	tParams = tParams or {}

	local init = {
		'TestCondition: ' .. strConditionName,
	}
	HandlerDebug (init, tParams)

	local success, ret

	if (TC and TC [strConditionName] and type (TC [strConditionName]) == 'function') then
		success, ret = pcall (TC [strConditionName], strConditionName, tParams)
	end

	if (success == true) then
		return (ret)
	elseif (success == false) then
		MetricsHandler:SetCounter ('Error_TestCondition')
		print ('TestCondition error: ', ret, strConditionName)
	end
end

function UIRequest (strCommand, tParams)
	strCommand = strCommand or ''
	tParams = tParams or {}

	local init = {
		'UIRequest: ' .. strCommand,
	}
	HandlerDebug (init, tParams)

	local success, ret

	if (UIR and UIR [strCommand] and type (UIR [strCommand]) == 'function') then
		success, ret = pcall (UIR [strCommand], tParams)
	end

	if (success == true) then
		return (ret)
	elseif (success == false) then
		print ('UIRequest Lua error: ', strCommand, ret)
	end
end end)
package.preload['drivers-common-public.global.lib'] = (function (...)
-- Copyright 2022 Snap One, LLC. All rights reserved.

COMMON_LIB_VER = 33

JSON = require ('drivers-common-public.module.json')

pcall (require, 'drivers-common-internal.global.production')

do	-- set AES and SHA defaults
	AES_DEC_DEFAULTS = {
		return_encoding = 'NONE',
		key_encoding = 'NONE',
		iv_encoding = 'NONE',
		data_encoding = 'BASE64',
		padding = true,
	}

	AES_ENC_DEFAULTS = {
		return_encoding = 'BASE64',
		key_encoding = 'NONE',
		iv_encoding = 'NONE',
		data_encoding = 'NONE',
		padding = true,
	}

	SHA_ENC_DEFAULTS = {
		return_encoding = 'NONE',
		data_encoding = 'NONE',
	}
end

do	-- Set common var IDs
	ROOM_VARS = {
		['CURRENT_SELECTED_DEVICE']		= 1000,
		['CURRENT_AUDIO_DEVICE']		= 1001,
		['CURRENT_VIDEO_DEVICE']		= 1002,
		['AUDIO_VOLUME_DEVICE']			= 1003,
		['VIDEO_VOLUME_DEVICE']			= 1004,
		['CURRENT_MEDIA']				= 1005,
		['CURRENT_AUDIO_PATH']			= 1007,
		['CURRENT_VIDEO_PATH']			= 1008,
		['CURRENT_VIDEO_AUDIO_PATH']	= 1009,
		['POWER_STATE']					= 1010,
		['CURRENT_VOLUME']				= 1011,
		['TEMPERATURE_ID']				= 1012,
		['TEMPERATURE_CONTROL_ID']		= 1013,
		['SECURITY_SYSTEM_ID']			= 1014,
		['CURRENT_VOLUME_DEVICE_ID']	= 1015,
		['HAS_DISCRETE_VOLUME']			= 1016,
		['HAS_DISCRETE_MUTE']			= 1017,
		['IS_MUTED']					= 1018,
		['IN_NAVIGATION	']				= 1019,
		['USE_DEFAULT_VOLUMES']			= 1020,
		['DEFAULT_AUDIO_VOLUME']		= 1021,
		['VOLUME_IS_LINKED']			= 1023,
		['DEFAULT_VIDEO_VOLUME']		= 1022,
		['LINKED_ROOM_LIST']			= 1024,
		['MUTE_IS_LINKED']				= 1025,
		['ROOMOFF_IS_LINKED']			= 1026,
		['SELECTIONS_LINKED']			= 1027,
		['CURRENT_LINKED_MEDIA_SCENE']	= 1028,
		['ROOM_HIDDEN']					= 1029,
		['MEDIA_SCENE_ACTIVE']			= 1030,
		['CURRENT MEDIA INFO'] 			= 1031,
		['LAST_DEVICE_GROUP']			= 1032,
		['AVAILABLE_CAMERAS']			= 1033,
		['POOLS']						= 1034,
		['SCENE_IS_DISCRETE_VOLUME']	= 1035,
		['PLAYING_AUDIO_DEVICE']		= 1036,
		['ANNOUNCEMENT_DISABLED']		= 1037,
	}

	DIGITAL_AUDIO_VARS = {
		['ROOM_HISTORY']				= 1002,
		['ROOM_QUEUE_SETTINGS']			= 1003,
		['QUEUE_STATUS']				= 1004,
		['QUEUE_INFO']					= 1005,
		['QUEUE_STATUS_V2']				= 1006,
		['QUEUE_INFO_V2']				= 1007,
		['PLAY_PREFERENCE']				= 1008,
		['ROOM_MAP_INFO']				= 1009,
		['AUDIO LATENCY PROFILE']		= 1010,
		['MAX_AUDIO_QUALITY']			= 1011,
		['AUDIO_MODE_VER']				= 1012,
		['AUDIO_FORCED_ADV']			= 2000,
	}

	PROJECT_VARS = {
		['ZIPCODE'] = 1000,
		['LATITUDE'] = 1001,
		['LONGITUDE'] = 1002,
	}
end

do -- LOCALE FIXING FOR tostring AND tonumber

	if (not tostring_native) then
		tostring_native = tostring
	end
	if (not tonumber_native) then
		tonumber_native = tonumber
	end

	LOCALE_USES_COMMA_DECIMAL_SEPARATORS = (tonumber ('0.5') == nil)

	function tostring_return_comma (v)
		local ret = tostring_native (v)
		if (type (v) == 'number') then
			ret = string.gsub (ret, '%.', '%,')
		end
		return (ret)
	end

	function tostring_return_period (v)
		local ret = tostring_native (v)
		if (type (v) == 'number') then
			ret = string.gsub (ret, '%,', '%.')
		end
		return (ret)
	end

	function tonumber_expect_comma (e, base)
		local ret = tonumber_native (e, base)
		if (ret == nil) then
			if (type (e) == 'string') then
				e = string.gsub (e, '%.', '%,')
				ret = tonumber_native (e, base)
			end
		end
		return (ret)
	end

	function tonumber_expect_period (e, base)
		local ret = tonumber_native (e, base)
		if (ret == nil) then
			if (type (e) == 'string') then
				e = string.gsub (e, '%,', '%.')
				ret = tonumber_native (e, base)
			end
		end
		return (ret)
	end

	if (LOCALE_USES_COMMA_DECIMAL_SEPARATORS) then
		tonumber = tonumber_expect_comma
	end
end

function dbg (strDebugText, ...)
	if (DEBUGPRINT) then
		local t, ms
		if (C4.GetTime) then
			t = C4:GetTime ()
			ms = '.' .. tostring (t % 1000)
			t = math.floor (t / 1000)
		else
			t = os.time ()
			ms = ''
		end
		local s = os.date ('%x %X') .. ms .. ' : '

		print (s .. (strDebugText or ''), ...)
		C4:DebugLog (strDebugText)
	end
end

function dbgdump (strDebugText, ...)
	if (DEBUGPRINT) then hexdump (strDebugText or '') print (...) end
end

function gettext (text)
	return (text)
end

function Print (data)
	if (type (data) == 'table') then
		for k, v in pairs (data) do print (k, v) end
	elseif (type (data) ~= 'nil') then
		print (type (data), data)
	else
		print ('nil value')
	end
end

function CopyTable (t, shallowCopy)
	if (type (t) ~= 'table') then
		return
	end

	local seenTables = {}

	local r = {}
	for k, v in pairs (t) do
		if (type (v) == 'number' or type (v) == 'string' or type (v) == 'boolean') then
			r [k] = v
		elseif (type (v) == 'table') then
			if (shallowCopy ~= true) then
				if (seenTables [v]) then
					r [k] = seenTables [v]
				else
					r [k] = CopyTable (v)
					seenTables [v] = r [k]
				end
			end
		end
	end
	return (r)
end

function VersionCheck (requires_version)
	local curver = {}
	curver [1], curver [2], curver [3], curver [4] = string.match (C4:GetVersionInfo ().version, '^(%d*)%.?(%d*)%.?(%d*)%.?(%d*)')
	local reqver = {}
	reqver [1], reqver [2], reqver [3], reqver [4] = string.match (requires_version, '^(%d*)%.?(%d*)%.?(%d*)%.?(%d*)')

	for i = 1, 4 do
		local cur = tonumber (curver [i]) or 0
		local req = tonumber (reqver [i]) or 0
		if (cur > req) then
			return true
		end
		if (cur < req) then
			return false
		end
	end
	return true
end

function GetLocationInfo ()
	local proj = XMLDecode (C4:GetProjectItems ('LOCATIONS', 'LIMIT_DEVICE_DATA', 'NO_ROOT_TAGS'))

	local lat = XMLCapture (proj, 'latitude>')
	local long = XMLCapture (proj, 'longitude>')
	local cc = XMLCapture (proj, 'country_code')
	local zip = XMLCapture (proj, 'zipcode')
	local city = XMLCapture (proj, 'city_name')
	local timezone = XMLCapture (proj, 'timezone')

	if (lat == '') then lat = nil end
	if (long == '') then long = nil end
	if (cc == '') then cc = nil end
	if (zip == '') then zip = nil end
	if (city == '') then city = nil end
	if (timezone == '') then timezone = nil end

	return lat, long, cc, zip, city, timezone
end

function GetTimeString (data, forceHours)
	-- Converts an integer number of seconds to a string of [HH:]MM:SS. If HH is zero, it is omitted unless forceHours is true

	if (type (data) == 'number') then
		local strTime = ''
		local strHours, strMinutes, strSeconds

		local seconds = data % 60
		local minutes = math.floor (data / 60) % 60
		local hours = math.floor (data / 3600)

		strHours = string.format('%d', hours)

		if (hours ~= 0 or forceHours) then
			strTime = strHours .. ':'
			strMinutes = string.format('%02d', minutes)
		else
			strMinutes = string.format('%d', minutes)
		end

		strSeconds = string.format('%02d', seconds)

		strTime = strTime .. strMinutes .. ':' .. strSeconds
		return strTime

	elseif (type (data) == 'string') then
		return data

	else
		return 0
	end
end

function GetTimeNumber (data)
	-- Converts a string of [HH:]MM:SS to an integer representing the number of seconds
	if (type (data) == 'string') then
		local hours, minutes, seconds = string.match (data, '^(%d-):(%d-):?(%d-)$')
		if (hours == '') then hours = nil end
		if (minutes == '') then minutes = nil end
		if (seconds == '') then seconds = nil end

		if (hours and not minutes) then
			minutes = hours
			hours = 0
		elseif (minutes and not hours ) then
			hours = 0
		elseif (not minutes and not hours) then
			minutes = 0
			hours = 0
			seconds = seconds or 0
		end

		hours, minutes, seconds = tonumber (hours), tonumber (minutes), tonumber (seconds)
		return ((hours * 3600) + (minutes * 60) + seconds)

	elseif (type (data) == 'number') then
		return data

	else
		return 0
	end
end

function ConvertTime (data, forceHours)
	if (type (data) == 'number') then
		return (GetTimeString (data, forceHours))

	elseif (type (data) == 'string') then
		return (GetTimeNumber (data))

	else
		return 0
	end
end

function RelativeTime (timeNow, timeThen, prefix)
	-- TODO : implement this with gettext for internationalization

	local diff = math.abs (timeNow - timeThen)
	local past = timeNow > timeThen
	local future = timeThen > timeNow

	local ret

	local words = {
		{ name = 'second', duration = 1 },
		{ name = 'minute', duration = 60 },
		{ name = 'hour', duration = 60 * 60 },
		{ name = 'day', duration = 24 * 60 * 60 },
		{ name = 'week', duration = 7 * 24 * 60 * 60 },
		{ name = 'month', duration = 30 * 24 * 60 * 60 },
		{ name = 'year', duration = 365 * 24 * 60 * 60 },
	}

	if (diff == 0) then
		ret = 'now'
	else
		for i, word in ipairs (words) do
			if (diff < word.duration) then
				ret = tostring (math.floor (diff / words [i-1].duration)) .. ' ' .. words [i-1].name .. 's'
				break
			elseif (diff < word.duration * 2) then
				if (word.name == 'hour') then
					ret = 'an hour'
				else
					ret = 'a ' .. word.name
				end
				break
			elseif (diff < word.duration * 5) then
				ret = 'a few ' .. word.name .. 's'
				break
			end
		end
	end

	if (ret == nil) then
		ret = 'a long time'
	end

	if (past) then
		ret = ret .. ' ago'
	elseif (future) then
		ret = ret .. ' from now'
	end

	if (type (prefix) == 'string') then
		ret = prefix .. ret
	end

	return ret
end

function XMLDecode (s)
	if (type (s) ~= 'string') then
		return (s)
	end

	s = string.gsub (s, '%<%!%[CDATA%[(.-)%]%]%>', function (a) return (a) end)

	s = string.gsub (s, '&quot;'	, '"')
	s = string.gsub (s, '&lt;'		, '<')
	s = string.gsub (s, '&gt;'		, '>')
	s = string.gsub (s, '&apos;'	, '\'')
	s = string.gsub (s, '&#x(.-);', function (a) return string.char (tonumber (a, 16) % 256) end )
	s = string.gsub (s, '&#(.-);',	function (a) return string.char (tonumber (a) % 256) end )
	s = string.gsub (s, '&amp;'	, 	'&')

	return s
end

function XMLEncode (s)
	if (type (s) ~= 'string') then
		return (s)
	end

	s = string.gsub (s, '&',	'&amp;')
	s = string.gsub (s, '"',	'&quot;')
	s = string.gsub (s, '<',	'&lt;')
	s = string.gsub (s, '>',	'&gt;')
	s = string.gsub (s, '\'',	'&apos;')
	return s
end

function XMLTag (strName, tParams, tagSubTables, xmlEncodeElements, tAttribs)
	local retXML = {}

	local addTag = function (tagName, closeTag)
		if (tagName == nil) then return end

		if (closeTag) then
			tagName = string.match (tostring (tagName), '^(%S+)')
		end

		if (tagName and tagName ~= '') then
			table.insert (retXML, '<')
			if (closeTag) then
				table.insert (retXML, '/')
			end
			table.insert (retXML, tostring (tagName))
			table.insert (retXML, '>')
		end
	end

	if (type (strName) == 'table' and tParams == nil) then
		tParams = strName
		strName = nil
	end

	if (strName and tAttribs and type (tAttribs) == 'table') then
		local attribs = {
			strName
		}
		for k, v in pairs (tAttribs) do
			local a = {
				tostring (k),
				'=',
				'"',
				XMLEncode (tostring (v)),
				'"',
			}
			a = table.concat (a)
			table.insert (attribs, a)
		end
		strName = table.concat (attribs, ' ')
	end

	addTag (strName)

	if (type (tParams) == 'table') then
		local arraySize = #tParams
		local tableSize = 0
		for _, _ in pairs (tParams) do
			tableSize = tableSize + 1
		end
		if (arraySize == tableSize) then
			for _, subItem in ipairs (tParams) do
				table.insert (retXML, XMLTag (nil, subItem, tagSubTables, xmlEncodeElements))
			end

		else
			for k, v in pairs (tParams) do
				if (v == nil) then v = '' end
				if (type (v) == 'table') then
					if (k == 'image_list') then
						for _, image_list in pairs (v) do
							table.insert (retXML, image_list)
						end
					elseif (tagSubTables == true) then
						table.insert (retXML, XMLTag (k, v, tagSubTables, xmlEncodeElements))
					end
				else
					if (v == nil) then v = '' end

					addTag (k)

					if (xmlEncodeElements ~= false) then
						table.insert (retXML, XMLEncode (tostring (v)))
					else
						table.insert (retXML, tostring (v))
					end

					addTag (k, true)
				end
			end
		end

	elseif (tParams) then
		if (xmlEncodeElements ~= false) then
			table.insert (retXML, XMLEncode (tostring (tParams)))
		else
			table.insert (retXML, tostring (tParams))
		end
	end

	addTag (strName,true)

	return (table.concat (retXML))
end

--[[
	-- tests on tag = tag
	local t1 = '<a>b</a><tag>test string</tag><a>b</a>' -- 'test string', nil
	local t2 = '<a>b</a><tag testattrib="testval" testattrib2="test val">test</tag><a>b</a>' -- test, {testattrib = 'testval', testattrib2 = 'test val'}
	local t3 = '<a>b</a><ta g>test string</tag><a>b</a>' -- nil, nil
	local t4 = '<a>b</a><tagattrib>asdf</tagattrib>' -- nil, nil
	local t5 = '<a>b</a><tag/><a>b</a>' -- '', nil
	local t6 = '<a>b</a><tag /><a>b</a>' -- '', nil
	local t7 = '<a>b</a><tag testattrib="testval" testattrib2="test val"/><a>b</a>' -- '', , {testattrib = 'testval', testattrib2 = 'test val'}
	local t8 = '<a>b</a><tag testattrib="testval" testattrib2="test val" /><a>b</a>' -- '', , {testattrib = 'testval', testattrib2 = 'test val'}
--]]

function XMLCapture (xmlString, tag)
	-- plain tag
	local tagContents = string.match (xmlString, '<' .. tag .. '>(.-)</' .. tag .. '>')
	if (tagContents) then
		return tagContents, nil
	end

	-- tag with attributes
	local attributes, tagContents = string.match (xmlString, '<' .. tag .. '%s+(%S.-)>(.-)</' .. tag .. '>')
	if (attributes and tagContents) then
		return tagContents, attributes
	end

	-- self closing tag
	local selfClosed = string.match (xmlString, '<' .. tag .. '%s-/>')
	if (selfClosed) then
		return '', nil
	end

	-- self closing tag with attributes
	local attributes = string.match (xmlString, '<' .. tag .. '%s+(%S.-)%s-/>')
	if (attributes) then
		return '', attributes
	end
end

function RefreshNavs ()
	local cli = C4:CreateTCPClient ()
	:OnConnect (function (client)
			client:Write ('<c4soap name="PIP" async="1"></c4soap>\0'):Close ()
	end)
	:OnError (function (client)
			client:Close ()
	end)

	cli:Connect ('127.0.0.1', 5020)
end

function HideProxyInAllRooms (idBinding)
	idBinding = idBinding or 0
	if (idBinding == 0) then return end -- silently fail if no binding passed in.

	-- Get Bound Proxy's Device ID / Name.
	local id, name = next(C4:GetBoundConsumerDevices(C4:GetDeviceID(), idBinding))

	-- Send hide command to all rooms, for 'ALL' Navigator groups.
	for roomid, roomname in pairs(C4:GetDevicesByC4iName('roomdevice.c4i') or {}) do
		dbg ('Hiding device:"' .. name .. '" in room "' .. roomname .. '"')
		C4:SendToDevice(roomid, 'SET_DEVICE_HIDDEN_STATE', {PROXY_GROUP = 'ALL', DEVICE_ID = id, IS_HIDDEN = true})
	end
end

function GetFileName (deviceId)
	if (deviceId == nil) then
		deviceId = C4:GetDeviceID ()
	end

	local info = C4:GetDevices ({DeviceIds = tostring (deviceId)})

	if (info and info [deviceId]) then
		local driverFileName = info [deviceId].driverFileName
		return driverFileName
	end
end

function F2C (f)
	if (type (f) ~= 'number') then
		return
	end
	local c = (f - 32) * (5 / 9)
	c = math.floor ((c * 2) + 0.5) / 2
	return (c)
end

function C2F (c)
	if (type (c) ~= 'number') then
		return
	end
	local f = (c * (9 / 5)) + 32
	f = math.floor (f + 0.5)
	return (f)
end

function Serialize (d)
	if (type (d) == 'table') then
		local j = JSON:encode (d)
		if (j) then
			local b64 = C4:Base64Encode (j)
			if (b64) then
				return (b64)
			end
		end
	end
	return (d)
end

function Deserialize (b64)
	if (type (b64) == 'string') then
		local j = C4:Base64Decode (b64)
		if (j) then
			local d = JSON:decode (j)
			if (d) then
				return (d)
			end
		end
	end
	return (b64)
end

function SaltedEncrypt (key, plaintext)
	local cipher = 'AES-256-CBC'
	local options = AES_ENC_DEFAULTS

	local prepend_random = {}
	for i = 1, 16 do
		local randomChar = string.char (math.random (0, 255))
		table.insert (prepend_random, randomChar)
	end
	prepend_random = table.concat (prepend_random)

	local data = prepend_random .. plaintext

	if (string.len (key) ~= 32) then
		key = C4:Hash ('SHA256', key, SHA_ENC_DEFAULTS)
	end

	local result, errString = C4:Encrypt (cipher, key, nil, data, options)
	return result, errString
end

function SaltedDecrypt (key, ciphertext)
	local cipher = 'AES-256-CBC'
	local options = AES_DEC_DEFAULTS

	local data = ciphertext

	if (string.len (key) ~= 32) then
		key = C4:Hash ('SHA256', key, SHA_ENC_DEFAULTS)
	end

	local result, error = C4:Decrypt (cipher, key, nil, data, options)

	if (result) then
		result = string.sub (result, 17, -1)
	end
	return result, error
end

function EscapeForLuaPattern (s)
	if (type (s) ~= 'string') then
		return
	end
	local matches = {
		['%'] = '%%',
		['^'] = '%^',
		['$'] = '%$',
		['('] = '%(',
		[')'] = '%)',
		['.'] = '%.',
		['['] = '%[',
		[']'] = '%]',
		['*'] = '%*',
		['+'] = '%+',
		['-'] = '%-',
		['?'] = '%?',
	}
	return string.gsub (s, '.', matches)
end

function ShowPopupEverywhere (message, ok, delay, imgUrl)
	local params = {
		VAR_DEVICE_ID = 0,
		SIZE = 100,
		MESSAGE = (message or ''),
		SHOWOK = (ok and 'True') or 'False',
		DELAY = (delay or 0),
		IMGURL = (imgUrl or ''),
		VAR_VARIABLE_ID = 0,
	}

	local uiDevices = C4:GetProxyDevicesByName ('uidevice')

	for deviceId, _ in pairs (uiDevices or {}) do
		C4:SendToDevice (deviceId, 'SHOW_POPUP', params, true)
	end
end

function HideCurrentPopupEverywhere ()
	local uiDevices = C4:GetProxyDevicesByName ('uidevice')

	for deviceId, _ in pairs (uiDevices or {}) do
		C4:SendToDevice (deviceId, 'HIDE_POPUP', {}, true)
	end
end

function GetProject ()
	local h = C4:GetProjectItems ('DEVICES', 'PROXIES', 'LOCATIONS', 'NO_ROOT_TAGS', 'LIMIT_DEVICE_DATA')
	h = string.gsub (h, '<state>.-</state>', '')
	h = string.gsub (h, '<itemdata>.-</itemdata>', '')
	h = string.gsub (h, '<created_datetime>.-</created_datetime>', '')
	h = string.gsub (h, '<%w+/>', '')
	h = string.gsub (h, '>%s+<', '><')
	h = string.gsub (h, '><', '>\r\n<')
	h = h .. '\r\n'

	local p = {'{"project" : '}

	local c

	local item = 0
	local subitem = 0
	for line in string.gmatch (h, '(.-)\r\n') do
		if (string.find (line, '^<item')) then
			table.insert (p, '{')
			item = item + 1

		elseif (string.find (line, '^</item>')) then
			table.insert (p, '},')
			item = item - 1

		elseif (string.find (line, '^<subitems>')) then
			table.insert (p, '"subItems" : [')
			subitem = subitem + 1

		elseif (string.find (line, '^</subitems>')) then
				table.insert (p, '],')
				subitem = subitem - 1

		elseif (string.find (line, '^<id>')) then
			local id = string.match (line, '<id>(.-)</id>')
			if (id) then
				table.insert (p, '"id" : ' .. id .. ',')
			end

		elseif (string.find (line, '^<c4i>')) then
			local c4i = string.match (line, '<c4i>(.-)</c4i>')
			if (c4i) then
				table.insert (p, '"c4i" : "' .. c4i .. '",')
			end

		elseif (string.find (line, '^<type>')) then
			local deviceType = string.match (line, '<type>(.-)</type>')
			if (deviceType) then
				table.insert (p, '"deviceType" : ' .. deviceType .. ',')
			end

		--[[
			1 = ROOT
			2 = SITE
			3 = BUILDING
			4 = FLOOR
			5 = ROOM
			6 = DEVICE
			7 = PROXY
			8 = ROOM_DEVICE
			9 = AGENT
		]]

		elseif (string.find (line, '^<name>')) then
			local name = string.match (line, '<name>(.-)</name>')
			if (name) then
				table.insert (p, '"name" : ' .. JSON:encode (name) .. ',')
			end
		end
	end

	table.insert (p, '}')

	p = table.concat (p, '\r\n')

	p = string.gsub (p, ',%s+%]', '\r\n%]')
	p = string.gsub (p, ',%s+%}', '\r\n%}')

	local j

	local f = function ()
		j = JSON:decode (p)
	end

	local success, err = pcall (f)

	return (j)
end

function GetPathToDevice (deviceId, project)
	if (type (project ~= 'table')) then
		project = GetProject ()
	end

	if (project and project.project) then
		project = project.project
	else
		return
	end

	deviceId = tonumber (deviceId)

	if (deviceId == nil) then
		return
	end

	local path = {}

	local drill
	drill = function (item)
		local id = item.id
		local thisItem = {
			id = item.id,
			name = item.name,
			c4i = item.c4i,
			deviceType = item.deviceType,
		}
		if (id == deviceId) then
			table.insert (path, thisItem)
			return (true)
		elseif (item.subItems) then
			for _, subItemTable in ipairs (item.subItems) do
				local found = drill (subItemTable)
				if (found) then
					table.insert (path, thisItem)
					return (true)
				end
			end
		end
	end

	drill (project)

	return (path)
end

function GetLocals (depth)
	local vars = {}
	local i = 1
	depth = depth or 2

	while (true) do
		local name, value = debug.getlocal (depth, i)
		if (name ~= nil) then
			vars [name] = value
		else
			break
		end
		i = i + 1
	end

	return vars
end

function GetRandomString (length, alphaFirst)
	if (type (length) ~= 'number') then
		length = 10
	end
	if (length < 1) then
		length = 1
	end
	if (type (alphaFirst) ~= 'boolean') then
		alphaFirst = false
	end

	local s = {}
	local allowed = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
	while (#s < length) do
		local max = string.len (allowed)
		if (#s == 0 and alphaFirst) then
			max = max - 10
		end
		local random = math.random (1, max)
		local char = string.sub (allowed, random, random)
		table.insert (s, char)
	end
	s = table.concat (s)
	return s
end

function FileRead (filename)
	local content = ''
	if (C4:FileExists (filename)) then
		local file = C4:FileOpen (filename)
		local length = C4:FileGetSize (file)
		C4:FileSetPos (file, 0)
		content = C4:FileRead (file, length)
		C4:FileClose (file)
	end
	return (content)
end

function FileWrite (filename, content, overwrite)
	content = tostring (content) or ''
	local pos = 0
	if (overwrite and C4:FileExists (filename)) then
		C4:FileDelete (filename)
	end
	local file = C4:FileOpen (filename)
	if (not overwrite) then
		pos = C4:FileGetSize (file)
	end
	C4:FileSetPos (file, pos)
	local result = C4:FileWrite (file, content:len (), content)
	C4:FileClose (file)
end

function PersistSetValue (key, value, encrypted)
	if (encrypted == nil) then
		encrypted = false
	end

	if (C4.PersistSetValue) then
		C4:PersistSetValue (key, value, encrypted)
	else
		PersistData = PersistData or {}
		PersistData.LibValueStore = PersistData.LibValueStore or {}
		PersistData.LibValueStore [key] = value
	end
end

function PersistGetValue (key, encrypted)
	if (encrypted == nil) then
		encrypted = false
	end

	local value

	if (C4.PersistGetValue) then
		value = C4:PersistGetValue (key, encrypted)
		if (value == nil and encrypted == true) then
			value = C4:PersistGetValue (key, false)
			if (value ~= nil) then
				PersistSetValue (key, value, encrypted)
			end
		end
		if (value == nil) then
			if (PersistData and PersistData.LibValueStore and PersistData.LibValueStore [key]) then
				value = PersistData.LibValueStore [key]
				PersistSetValue (key, value, encrypted)
				PersistData.LibValueStore [key] = nil
				if (next (PersistData.LibValueStore) == nil) then
					PersistData.LibValueStore = nil
				end
			end
		end
	elseif (PersistData and PersistData.LibValueStore and PersistData.LibValueStore [key]) then
		value = PersistData.LibValueStore [key]
	end
	return value
end

function PersistDeleteValue (key)
	if (C4.PersistDeleteValue) then
		C4:PersistDeleteValue (key)
	else
		if (PersistData and PersistData.LibValueStore) then
			PersistData.LibValueStore [key] = nil
			if (next (PersistData.LibValueStore) == nil) then
				PersistData.LibValueStore = nil
			end
		end
	end
end

function Select (data, ...)
	if (type (data) ~= 'table') then
		return nil
	end

	local tablePack = function (...)
		return {
			n = select ('#', ...), ...
		}
	end

	local args = tablePack (...)

	local ret = data

	for i = 1, args.n do
		local index = args [i]
		if (index == nil or ret [index] == nil) then
			return nil
		end
		if (ret [index] ~= nil) then
			ret = ret [index]
		end
	end
	return ret
end

function GetConnections ()
	local connectionsXML = C4:GetDriverConfigInfo ('connections')

	local connections = {}
	for connection in string.gmatch (connectionsXML, '<connection>(.-)</connection>') do
		local id = tonumber (XMLCapture (connection, 'id'))
		if (id) then
			local classesXML = XMLCapture (connection, 'classes') or ''

			local classes = {}

			for class in string.gmatch (classesXML, '<class>(.-)</class>') do
				table.insert (classes, {
					classname = XMLCapture (class, 'classname'),
					autobind = (XMLCapture (class, 'autobind') == 'True'),
				})
			end

			connections [id] = {
				id = id,
				type = tonumber (XMLCapture (connection, 'type')),
				connectionname = XMLCapture (connection, 'name'),
				consumer = (XMLCapture (connection, 'consumer') == 'True'),
				linelevel = (XMLCapture (connection, 'linelevel') == 'True'),
				idautobind = XMLCapture (connection, 'idautobind'),
				classes = classes,
			}
		end
	end
	return connections
end

function GetTableSize (t)
	if (type (t) ~= 'table') then
		return 0
	end

	local size = 0
	for _, _ in pairs (t) do
		size = size + 1
	end
	return size
end end)
package.preload['drivers-common-public.global.make_short_link'] = (function (...)
-- Copyright 2020 Wirepath Home Systems, LLC. All rights reserved.

MAKE_SHORT_LINK_VER = 8

require ('drivers-common-public.global.url')

function MakeShortLink (link, callback, apiKey)
	local url
	if (IN_PRODUCTION) then
		url = 'https://link.ctrl4.co/new'
	else
		url = 'https://link.control4driversdev.com/new'
	end

	local data = {
		url = link,
	}

	local headers = {
		Authorization = apiKey
	}

	local contextInfo = {
		link = link,
		callback = callback,
	}

	urlPost (url, data, headers, MakeShortLinkResponse, contextInfo)
end

function MakeShortLinkResponse (strError, responseCode, tHeaders, data, context, url)
	if (strError) then
		dbg ('Error with MakeShortLinkResponse:', strError)
		return
	end

	local link = context.link
	local callback = context.callback

	local expiresAt

	if (responseCode == 200) then
		link = data.url
		expiresAt = data.expiresAt
	end

	if (link) then
		if (callback and type (callback) == 'function') then
			pcall (callback, link, expiresAt)
		end
	end
end
 end)
package.preload['drivers-common-public.global.msp'] = (function (...)
-- Copyright 2022 Snap One, LLC. All rights reserved.

COMMON_MSP_VER = 98

JSON = require ('drivers-common-public.module.json')

require ('drivers-common-public.global.lib')
require ('drivers-common-public.global.handlers')
require ('drivers-common-public.global.timer')
require ('drivers-common-public.global.url')

Metrics = require ('drivers-common-public.module.metrics')

function JSON:assert()
	-- We don't want the JSON library to assert but rather return nil in case of parsing errors
end

do	--Globals
	Navigators = Navigators or {}
	SongQs = SongQs or {}

	QueueMap = QueueMap or {}
	RoomQIDMap = RoomQIDMap or {}

	RoomSettings = RoomSettings or {}

	Navigator = Navigator or {}

	MAX_SEARCH = 20

	QUEUE_WINDOW_HALF = 100

	MAX_SKIPS = 5
	SKIP_TIMEOUT = ONE_HOUR

	MAX_LIST_SIZE = 1000

	REPEAT_METATABLE = {
		__index = function (self, key)
			local ret = rawget (self, key)
			if (ret) then
				return (ret)
			end

			if (type (key) == 'number') then
				if (self._parent and self._parent.REPEAT) then
					local mod = key % #self
					if (mod == 0) then mod = #self end
					local ret = rawget (self, mod)
					if (ret) then
						return (ret)
					end
				end
			end
		end
	}

	CUSTOM_DASH_ACTIONS = {
		Shuffle = true,
		Repeat = true,
		ThumbsUp = true,
		ThumbsUpCancel = true,
		ThumbsDown = true,
		ThumbsDownCancel = true,
	}

	DEBUG_DATA_RECEIVED = false
	DEBUG_SEND_EVENT = false
end

do -- define proxy / binding IDs
	MSP_PROXY = 5001
end

do	--Setup Metrics
	MetricsMSP = Metrics:new ('dcp_msp', COMMON_MSP_VER)
end

function OnDriverDestroyed ()
	C4:UnregisterSystemEvent (C4SystemEvents.OnPIP, 0)

	UnregisterVariableListener (C4_DIGITAL_AUDIO, DIGITAL_AUDIO_VARS.ROOM_QUEUE_SETTINGS)
	UnregisterVariableListener (C4_DIGITAL_AUDIO, DIGITAL_AUDIO_VARS.ROOM_MAP_INFO)

	C4:SendToProxy (MSP_PROXY, 'MQA_ENABLED_STATE', {ENABLED = false}, 'COMMAND')

	KillAllTimers ()

	if (OnDriverDestroyedTasks and type (OnDriverDestroyedTasks) == 'function') then
		local success, ret = pcall (OnDriverDestroyedTasks)
		if (success) then
			if (ret) then
			end
		else
			dbg ('OnDriverDestroyedTasks: an error occured: ' .. ret)
		end
	end
end

function OnDriverInit ()
	C4:RegisterSystemEvent (C4SystemEvents.OnPIP, 0)
	if (OnDriverInitTasks and type (OnDriverInitTasks) == 'function') then
		local success, ret = pcall (OnDriverInitTasks)
		if (success) then
			if (ret) then
			end
		else
			dbg ('OnDriverInitTasks: an error occured: ' .. ret)
		end
	end
end

function OnDriverLateInit ()
	if (not C4.GetDriverConfigInfo or not (VersionCheck (C4:GetDriverConfigInfo ('minimum_os_version')))) then
		local errtext = {
			'DRIVER DISABLED - ',
			C4:GetDriverConfigInfo ('model'),
			'driver',
			C4:GetDriverConfigInfo ('version'),
			'requires at least C4 OS',
			C4:GetDriverConfigInfo ('minimum_os_version'),
			': current C4 OS is',
			C4:GetVersionInfo ().version,
		}
		errtext = table.concat (errtext, ' ')

		C4:UpdateProperty ('Driver Version', errtext)
		for property, _ in pairs (Properties) do
			C4:SetPropertyAttribs (property, 1)
		end
		C4:SetPropertyAttribs ('Driver Version', 0)
		C4:SendToProxy (MSP_PROXY, 'DISABLE_DRIVER', {}, 'COMMAND')
		return
	end

	OPC.Debug_Mode (Properties ['Debug Mode'])

	KillAllTimers ()
	if (C4.AllowExecute) then C4:AllowExecute (not (IN_PRODUCTION)) end

	C4:urlSetTimeout (10)

	for _, var in ipairs (UserVariables or {}) do
		local default = var.default
		if (default == nil) then
			if (var.varType == 'STRING') then default = ''
			elseif (var.varType == 'BOOL') then default = '0'
			elseif (var.varType == 'NUMBER') then default = 0
			end
		end
		local readOnly = (var.readOnly ~= nil and var.readOnly) or true
		local hidden = (var.hidden ~= nil and var.hidden) or false
		C4:AddVariable (var.name, default, var.varType, readOnly, hidden)
	end

	C4_DIGITAL_AUDIO = next (C4:GetDevicesByC4iName ('control4_digitalaudio.c4i'))
	if (C4_DIGITAL_AUDIO) then
		RegisterVariableListener (C4_DIGITAL_AUDIO, DIGITAL_AUDIO_VARS.ROOM_QUEUE_SETTINGS, OWVC.ParseQueueSettingsInfo)
		RegisterVariableListener (C4_DIGITAL_AUDIO, DIGITAL_AUDIO_VARS.ROOM_MAP_INFO, OWVC.ParseRoomMapInfo)
	end

	RegisterRooms ()

	PersistData = PersistData or {}
	PersistData.AuthSettings = PersistData.AuthSettings or {}

	-- update security on stored password
	if (PersistData.AuthSettings.password) then
		local _update = function ()
			local password = C4:Decrypt ('AES-256-ECB', C4:GetDriverConfigInfo ('model'), nil, PersistData.AuthSettings.password, AES_DEC_DEFAULTS)
			if (password) then
				local enc_password = C4:Encrypt ('AES-256-CBC', C4:GetDriverConfigInfo ('model'), nil, password, AES_ENC_DEFAULTS)
				if (enc_password) then
					PersistData.AuthSettings.password = enc_password
				end
			end
		end

		pcall (_update)
	end

	Search = PersistData.Search or {}
	PersistData.Search = Search

	DEVICE_ID = C4:GetDeviceID ()
	PROXY_ID = C4:GetProxyDevices ()

	SUPPORTS_GAPLESS = VersionCheck ('2.10.0')
	SUPPORTS_CUSTOM_DASH = VersionCheck ('3.0.0')
	SUPPORTS_DEFAULT_AND_ACTIONS = VersionCheck ('3.0.0')
	SUPPORTS_SEEK_ABSOLUTE = VersionCheck ('3.3.1')

	USER_AGENT = 'Control4/' .. C4:GetVersionInfo ().version .. '/' .. C4:GetDriverConfigInfo ('model') .. '/' .. C4:GetDriverConfigInfo ('version')

	HomeTabId = 'Library'
	HomeScreenId = 'LibraryScreen'

	for property, _ in pairs (Properties) do
		OnPropertyChanged (property)
	end

	PersistData.VERSION = PersistData.VERSION or C4:GetDriverConfigInfo ('version')

	if (PersistData.VERSION ~= C4:GetDriverConfigInfo ('version')) then
		SetTimer ('RefreshNavs', math.random (30, 60) * ONE_SECOND)
	end

	if (OnDriverLateInitTasks and type (OnDriverLateInitTasks) == 'function') then
		local success, ret = pcall (OnDriverLateInitTasks)
		if (success) then
			if (ret) then
			end
		else
			dbg ('OnDriverLateInitTasks: an error occured: ' .. ret)
		end
	end
end

function OPC.Debug_Mode (value)
	CancelTimer ('DEBUGPRINT')
	DEBUGPRINT = (value == 'On')

	if (DEBUGPRINT) then
		local _timer = function (timer)
			C4:UpdateProperty ('Debug Mode', 'Off')
			OnPropertyChanged ('Debug Mode')
		end
		SetTimer ('DEBUGPRINT', 36000000, _timer)
	end
end

function OPC.Driver_Version (value)
	local version = C4:GetDriverConfigInfo ('version')
	if (not (IN_PRODUCTION)) then
		version = version .. ' DEV VERSION DO NOT SHIP'
	end
	C4:UpdateProperty ('Driver Version', version)
end

function OPC.Progress_Bar_Updates (value)
	UPDATE_FREQ = string.match (value, '^(%d+)')
	if (UPDATE_FREQ == nil) then
		SendEvent (MSP_PROXY, nil, nil, 'ProgressChanged', {})
	end
end

function OPC.Hide_album_track_images (value)
	HIDE_ALBUM_TRACK_IMAGES = (value == 'On')
end

function OPC.Tag_Explicit_Tracks (value)
	TAG_EXPLICIT_TRACKS = (value == 'On')
end

function OSE.OnPIP (event)
	PersistData.VERSION = C4:GetDriverConfigInfo ('version')
	PersistData.LastRefreshNavTime = os.time ()

	CancelTimer ('RefreshNavs')

	RegisterRooms ()

	if (RefreshNavTasks and type (RefreshNavTasks) == 'function') then
		local success, ret = pcall (RefreshNavTasks)
		if (success) then
			if (ret) then
			end
		else
			dbg ('RefreshNavTasks: an error occured: ' .. ret)
		end
	end
end

function OWVC.ParseRoomIdRoute (idDevice, idVariable, strValue)
	local roomId = tonumber (idDevice)
	RoomIDRoutes [roomId] = {}
	for id in string.gmatch (strValue or '', '<id>(.-)</id>') do
		table.insert (RoomIDRoutes [roomId], tonumber (id))
	end
end

function OWVC.ParseRoomIdSource (idDevice, idVariable, strValue)
	local roomId = tonumber (idDevice)
	local deviceId = tonumber (strValue) or 0
	RoomIDSources [roomId] = deviceId
end

function OWVC.ParseRoomIdPlayingSource (idDevice, idVariable, strValue)
	local roomId = tonumber (idDevice)
	local deviceId = tonumber (strValue) or 0
	RoomIDPlayingSources [roomId] = deviceId

	if (RoomIDSources [roomId] == C4_DIGITAL_AUDIO) then
		RoomIDDigitalMedia [roomId] = deviceId
	else
		RoomIDDigitalMedia [roomId] = 0
	end
end

function OWVC.ParseRoomMapInfo (idDevice, idVariable, strValue)
	local info = strValue or ''
	QueueMap = {}
	RoomQIDMap = {}

	for audioQueueInfo in string.gmatch (info, '<audioQueueInfo>(.-)</audioQueueInfo>') do
		local queue = string.match (audioQueueInfo, '<queue>(.-)</queue>')

		local qId = tonumber (string.match (queue, '<id>(.-)</id>'))

		local source = tonumber (string.match (queue, '<device_id>(.-)</device_id>'))
		local state = string.match (queue, '<state>(.-)</state>')
		local ownerId = tonumber (string.match (queue, '<owner>(.-)</owner>'))

		QueueMap [qId] = {
			source = source,
			state = state,
			ownerId = ownerId,
			qId = qId,
		}

		table.insert (QueueMap [qId], ownerId)

		local rooms = string.match (queue, '<rooms>(.-)</rooms>')

		for roomId in string.gmatch (rooms, '<id>(.-)</id>') do
			roomId = tonumber (roomId)
			if (roomId ~= ownerId) then
				table.insert (QueueMap [qId], roomId)
			end
			RoomQIDMap [roomId] = qId
		end
	end
end

function OWVC.ParseQueueSettingsInfo (idDevice, idVariable, strValue)
	local info = strValue or ''
	RoomSettings = {}

	for room_info in string.gmatch (info, '<room_info>(.-)</room_info>') do
		local roomId = tonumber (string.match (room_info, '<roomid>(.-)</roomid>'))
		local s = string.match (room_info, '<shuffle>(.-)</shuffle>')
		local r = string.match (room_info, '<repeat>(.-)</repeat>')

		RoomSettings [roomId] = {
			SHUFFLE = (s == '1'),
			REPEAT = (r == '1'),
		}
	end
end

RFP [MSP_PROXY] = function (idBinding, strCommand, tParams, args)
	if (strCommand == 'PLAY' or strCommand == 'PAUSE' or strCommand == 'STOP') then
		local roomId = tonumber (tParams.ROOMID) or tonumber (tParams.ROOM_ID)
		local qId = GetQueueIDByRoomID (roomId)
		local thisQ = SongQs [qId]
		if (thisQ) then
			LogPlayEvent ('user', qId, strCommand)
		end
		SetNextTrackURL ('', roomId)
	end

	local navId = tParams.NAVID
	local nav = Navigators [navId]

	if (strCommand == 'DESTROY_NAVIGATOR' or strCommand == 'DESTROY_NAV') then
		if (nav) then
			nav.DestroyNavTimer = SetTimer (nav.DestroyNavTimer, 5 * ONE_SECOND, function (timer) Navigators [navId] = nil end)
		end
		return

	elseif (strCommand == 'INTERNET_RADIO_SELECTED' or strCommand == 'AUDIO_URL_SELECTED') then
		OnInternetRadioSelected (idBinding, tParams)

	elseif (strCommand == 'SELECT_INTERNET_RADIO_ERROR' or strCommand == 'SELECT_AUDIO_URL_ERROR') then
		OnInternetRadioSelectedError (idBinding, tParams)

	elseif (strCommand == 'QUEUE_DELETED') then
		OnQueueDeleted (idBinding, tParams)

	elseif (strCommand == 'QUEUE_INFO_CHANGED') then
		OnQueueInfoChanged (idBinding, tParams)

	elseif (strCommand == 'QUEUE_MEDIA_INFO_UPDATED') then
		OnQueueMediaInfoUpdated (idBinding, tParams)

	elseif (strCommand == 'QUEUE_NEED_NEXT') then
		OnQueueNeedNext (idBinding, tParams)

	elseif (strCommand == 'QUEUE_STATE_CHANGED') then
		OnQueueStateChanged (idBinding, tParams)

	elseif (strCommand == 'QUEUE_STREAM_STATUS_CHANGED') then
		OnQueueStreamStatusChanged (idBinding, tParams)

	elseif (strCommand == 'DEVICE_SELECTED') then
		local itemId = tParams.location
		local roomId = tonumber (tParams.idRoom)

		if (itemId == '') then itemId = nil end

		if (CheckRoomHasDigitalAudio (roomId) == false) then
			dbg ('Tried to select digital audio in room with no Digital Audio:', roomId)
			return
		end

		if (itemId) then
			if (SelectMediaDBItemInRoom and type (SelectMediaDBItemInRoom) == 'function') then
				local success, ret = pcall (SelectMediaDBItemInRoom, itemId, roomId)
				if (success) then
					if (ret) then
					end
				else
					dbg ('SelectMediaDBItemInRoom: an error occured: ' .. ret)
				end
			end

		else
			local qId = GetQueueIDByRoomID (roomId)
			if (qId == 0) then
				local session = 0
				for qId, _ in pairs (SongQs or {}) do
					if (qId > session) then
						session = qId
					end
				end

				if (session and session > 0) then
					JoinRoomToSession (roomId, session)

				else
					if (SelectDefaultItemInRoom and type (SelectDefaultItemInRoom) == 'function') then
						local success, ret = pcall (SelectDefaultItemInRoom, roomId)
						if (success) then
							if (ret) then
							end
						else
							dbg ('SelectDefaultItemInRoom: an error occured: ' .. ret)
						end
					end
				end
			end
		end

	elseif (strCommand == 'PLAY') then
		if (navId and tParams.SEQ) then
			DataReceived (idBinding, navId, tParams.SEQ, '')
		end

		local roomId = tonumber (tParams.ROOMID) or tonumber (tParams.ROOM_ID)
		return (Play (roomId))

	elseif (nav == nil and strCommand == 'SKIP_FWD') then
		local roomId = tonumber (tParams.ROOMID) or tonumber (tParams.ROOM_ID)
		return (SkipFwd (roomId))

	elseif (nav == nil and strCommand == 'SKIP_REV') then
		local roomId = tonumber (tParams.ROOMID) or tonumber (tParams.ROOM_ID)
		return (SkipRev (roomId))

	elseif (strCommand == 'SEEK') then
		local roomId = tonumber (tParams.ROOMID) or tonumber (tParams.ROOM_ID)
		local pos = tonumber (tParams.POSITION)
		local seekType = tParams.TYPE
		return (Seek (roomId, pos, seekType))

	elseif (strCommand == 'SCAN_FWD') then
		local roomId = tonumber (tParams.ROOMID) or tonumber (tParams.ROOM_ID)
		local pos = 15
		local seekType = 'relative'
		return (Seek (roomId, pos, seekType))

	elseif (strCommand == 'SCAN_REV') then
		local roomId = tonumber (tParams.ROOMID) or tonumber (tParams.ROOM_ID)
		local pos = -15
		local seekType = 'relative'
		return (Seek (roomId, pos, seekType))

	elseif (string.find (strCommand, '^NUMBER_')) then
		-- TODO
		return '<ret><handled>true</handled></ret>'

	elseif (strCommand == 'REPEAT_ON') then
		local roomId = tonumber (tParams.ROOM_ID)
		local qId = GetQueueIDByRoomID (roomId)
		QueueSetRepeat (qId)

	elseif (strCommand == 'REPEAT_OFF') then
		local roomId = tonumber (tParams.ROOM_ID)
		local qId = GetQueueIDByRoomID (roomId)
		QueueClearRepeat (qId)

	elseif (strCommand == 'SHUFFLE_ON') then
		local roomId = tonumber (tParams.ROOM_ID)
		local qId = GetQueueIDByRoomID (roomId)
		QueueSetShuffle (qId)

	elseif (strCommand == 'SHUFFLE_OFF') then
		local roomId = tonumber (tParams.ROOM_ID)
		local qId = GetQueueIDByRoomID (roomId)
		QueueClearShuffle (qId)

	elseif (not (navId) and RFP) then
		strCommand = string.gsub (strCommand, '%s+', '_')
		if (RFP [strCommand]) then
			return RFP [strCommand] (tParams, args, idBinding)
		end

	elseif (nav == nil and navId) then
		nav = Navigator:new (navId)
		Navigators [navId] = nav
	end

	if (nav) then
		nav.DestroyNavTimer = SetTimer (nav.DestroyNavTimer, 3 * ONE_HOUR, function (timer) Navigators [navId] = nil end)

		local cmd = nav [strCommand]

		if (cmd == nil) then
			dbg ('ReceivedFromProxy: Unhandled nav command = ' .. strCommand)
			return
		end

		nav.roomId = tonumber (tParams.ROOMID)
		local seq = tParams.SEQ

		local success, ret = pcall (cmd, nav, idBinding, seq, args)

		if (success) then
			if (ret) then
				DataReceived (idBinding, navId, seq, ret)
			end
		else
			dbg ('Called nav command ' .. strCommand .. '.	An error occured: ' .. ret)
			DataReceivedError (idBinding, navId, seq, ret)
		end
	end
end

--Common MSP functions
function DataReceivedError (idBinding, navId, seq, msg)
	local tParams = {
		NAVID = navId,
		SEQ = seq,
		DATA = '',
		ERROR = msg,
	}
	C4:SendToProxy (idBinding, 'DATA_RECEIVED', tParams)
end

function DataReceived (idBinding, navId, seq, args)
	local data = ''

	if (type (args) == 'string') then
		data = args
	elseif (type (args) == 'boolean' or type (args) == 'number') then
		data = tostring (args)
	elseif (type (args) == 'table') then
		data = XMLTag (nil, args, false, false)
	end

	local tParams = {
		NAVID = navId,
		SEQ = seq,
		DATA = data,
	}

	if (DEBUG_DATA_RECEIVED) then
		print ('DATA_RECEIVED')
		Print (tParams)
	end

	C4:SendToProxy (idBinding, 'DATA_RECEIVED', tParams)
end

function SendEvent (idBinding, navId, roomId, name, args)
	local data = ''

	if (type (args) == 'string') then
		data = args
	elseif (type (args) == 'boolean' or type (args) == 'number') then
		data = tostring (args)
	elseif (type (args) == 'table') then
		data = XMLTag (nil, args, false, false)
	end

	if (type (roomId) == 'table') then
		roomId = table.concat (roomId, ',')
	end

	local tParams = {
		NAVID = navId,
		ROOMS = roomId,
		NAME = name,
		EVTARGS = data,
	}

	if (DEBUG_SEND_EVENT) then
		print ('SEND_EVENT')
		Print (tParams)
	end

	C4:SendToProxy (idBinding, 'SEND_EVENT', tParams, 'COMMAND')
end

function NetworkError (strError)
	dbg ('Network error: ' .. (strError or ''))
	local params = {
		Id = 'ErrorHandler',
		Title = '',
		Message = 'No response to this request.  Please try again.',
	}
	SendEvent (MSP_PROXY, nil, nil, 'DriverNotification', params)
end

-- Queue functions
function AddTracksToQueue (trackList, roomId, playOption, radioInfo, radioSkips)
	if (CheckRoomHasDigitalAudio (roomId) == false) then
		dbg ('Tried to create digital audio queue in room with no Digital Audio:', roomId)
		--return
	end

	local qId = GetQueueIDByRoomID (roomId)
	local thisQ = SongQs [qId] or SongQs [roomId]

	local idInQ = (thisQ and thisQ.idInQ) or 1

	for _, item in ipairs (trackList or {}) do
		item.image_list = MakeImageList (item)
		item.idInQ = idInQ
		idInQ = idInQ + 1
	end

	local playNow = false

	if (thisQ) then
		local pos, clearQ, logStop
		QueueClearShuffle (qId)

		if (thisQ.STREAM or (thisQ.RADIO and playOption ~= 'RADIO_NEXT')) then
			clearQ = true
		end

		thisQ.idInQ = idInQ
		pos = #thisQ.Q + 1

		if (playOption == 'NOW') then
			playNow = true

		elseif (playOption == 'NEXT') then
			pos = thisQ.CurrentTrack + 1

		elseif (playOption == 'ADD') then

		elseif (playOption == 'REPLACE') then
			clearQ = true

		elseif (playOption == 'SHUFFLE') then
			clearQ = true

		elseif (playOption == 'STREAM') then
			clearQ = true

		elseif (playOption == 'RADIO') then
			clearQ = true
			thisQ.SKIPS = radioSkips or 0

		elseif (playOption == 'RADIO_NEXT') then
			playNow = true
		end

		local nextTrackIndex = (playOption == 'SHUFFLE' and math.random (#trackList)) or 1

		if (playNow or clearQ) then
			LogPlayEvent ('user', qId, 'NEW_TRACKS_ADDED', trackList [nextTrackIndex])
		end

		if (clearQ) then
			thisQ.Q = {}
			thisQ.Q._parent = thisQ
			setmetatable (thisQ.Q, REPEAT_METATABLE)
			pos = 1
			playNow = true
		end

		if (playOption == 'RADIO') then
			thisQ.RADIO = radioInfo
			thisQ.STREAM = nil

		elseif (playOption == 'STREAM') then
			thisQ.STREAM = radioInfo
			thisQ.RADIO = nil

		elseif (playOption == 'RADIO_NEXT') then

		else
			thisQ.RADIO = nil
			thisQ.STREAM = nil
		end

		for _, item in ipairs (trackList) do
			table.insert (thisQ.Q, pos, item)
			pos = pos + 1
		end

		if (playOption == 'SHUFFLE') then
			thisQ.CurrentTrack = nextTrackIndex
			QueueSetShuffle (qId)
			trackList = thisQ.Q
		end

		thisQ.nowPlayingTags.can_shuffle = (thisQ.RADIO == nil) and (thisQ.STREAM == nil)
		thisQ.nowPlayingTags.can_repeat = (thisQ.RADIO == nil) and (thisQ.STREAM == nil)

		UpdateQueue (qId)
		UpdateDashboard (qId)

	else
		playNow = true
		qId = roomId

		local isRadio = (playOption == 'RADIO' and radioInfo) or nil
		local isStream = (playOption == 'STREAM' and radioInfo) or nil

		SongQs [roomId] = {
			Q = trackList,
			RADIO = isRadio,
			STREAM = isStream,
			SKIPS = radioSkips or 0,
			REPEAT = (not (isRadio or isStream)) and RoomSettings [roomId] and RoomSettings [roomId].REPEAT,
			CurrentTrack = 1,
			CurrentTrackElapsed = 0,
			idInQ = idInQ,
			nowPlayingTags = {
				can_shuffle = (not (isRadio or isStream)),
				can_repeat = (not (isRadio or isStream)),
			},
		}

		if (playOption == 'SHUFFLE') then
			SongQs [roomId].CurrentTrack = math.random (#trackList)
			QueueSetShuffle (roomId)
			trackList = SongQs [roomId].Q
		end

		MetricsMSP:SetCounter ('NewQueueAttempt')
		MetricsMSP:SetGauge ('QueueCount', GetTableSize (SongQs))
	end

	if (playNow) then
		local _, nextTrack = next (trackList or {})

		if (nextTrack and roomId) then
			GetTrackURLAndPlay (nextTrack, roomId)
		end
	end

	return qId, playNow
end

function PlayTrackURL (url, roomId, idInQ, flags, nextURL, position, hardPause)
	if (CheckRoomHasDigitalAudio (roomId) == false) then
		dbg ('Tried to start digital audio in room with no Digital Audio:', roomId)
		--return
	end

	local qId = GetQueueIDByRoomID (roomId)
	local thisQ = SongQs [qId] or SongQs [roomId]

	if (not url or url == '') then
		return
	end

	if (thisQ) then
		thisQ.trackStartEvented = false
		thisQ.trackStopEvented = false
		thisQ.trackStarted = os.time ()
		thisQ.nextUrlSent = (not (nextURL == nil or nextURL == ''))
		thisQ.nextUrlRequested = false
		thisQ.nextProgrammedTrackRequested = false
		thisQ.CurrentTrackElapsed = (position and math.floor (position / ONE_SECOND)) or 0
		thisQ.ProgressTimer = CancelTimer (thisQ.ProgressTimer)

		if (idInQ ~= nil) then
			for i, track in ipairs (thisQ.Q) do
				if (idInQ == track.idInQ) then
					thisQ.CurrentTrack = i
				end
			end
		end
	end

	if (type (flags) ~= 'table') then
		flags = {}
	end
	flags.driver = C4:GetDriverConfigInfo ('model')

	local f = {}
	for k, v in pairs (flags) do
		local thisFlag = tostring (k) .. '=' .. tostring (v)
		table.insert (f, thisFlag)
	end
	flags = table.concat (f, ',')

	MetricsMSP:SetCounter ('TrackPlayAttempt')

	if (idInQ == nil) then
		idInQ = tostring (os.time ())
	end

	local params = {
		ROOM_ID = roomId,
		STATION_URL = url,
		QUEUE_INFO = idInQ,
		FLAGS = flags,
		NEXT_URL = nextURL,
		POSITION = position,
		HARD_PAUSE = hardPause,
	}

	local command = 'SELECT_AUDIO_URL'
	if (not (VersionCheck ('2.10.0'))) then
		command = 'SELECT_INTERNET_RADIO'
		params.REPORT_ERRORS = true
	end
	C4:SendToProxy (MSP_PROXY, command, params, 'COMMAND')
end

function SetNextTrackURL (nextURL, roomId, idInQ, flags)
	local qId = GetQueueIDByRoomID (roomId)
	local thisQ = SongQs [qId]

	if (not nextURL or nextURL == '') then
		return
	end

	if (thisQ) then
		thisQ.nextUrlSent = (not (nextURL == nil or nextURL == ''))
		thisQ.nextUrlRequested = false
	end

	if (type (flags) ~= 'table') then
		flags = {}
	end
	flags.driver = C4:GetDriverConfigInfo ('model')

	local f = {}
	for k, v in pairs (flags) do
		local thisFlag = tostring (k) .. '=' .. tostring (v)
		table.insert (f, thisFlag)
	end
	flags = table.concat (f, ',')

	MetricsMSP:SetCounter ('NextTrackPlayAttempt')

	local params = {
		REPORT_ERRORS = true,
		ROOM_ID = roomId,
		QUEUE_INFO = idInQ,
		FLAGS = flags,
		NEXT_URL = nextURL,
	}

	C4:SendToProxy (MSP_PROXY, 'SET_NEXT_AUDIO_URL', params, 'COMMAND')
end

function QueueSetRepeat (qId)
	local thisQ = SongQs [qId]
	if (thisQ) then
		if (not (thisQ.REPEAT or thisQ.STREAM or thisQ.RADIO)) then
			thisQ.REPEAT = true
			thisQ.Q._repeat = true

			local roomId = GetRoomMapByQueueID (qId) [1]
			if (roomId) then
				SetNextTrackURL ('', roomId)
				C4:SendToDevice (C4_DIGITAL_AUDIO, 'REPEAT', {ROOM_ID = roomId, REPEAT = ((thisQ.REPEAT and 1) or 0)})
			end
		end
		UpdateQueue (qId, {suppressList = true})
		UpdateDashboard (qId)
	end
end

function QueueClearRepeat (qId)
	local thisQ = SongQs [qId]
	if (thisQ) then
		if (not (not (thisQ.REPEAT) or thisQ.STREAM or thisQ.RADIO)) then
			thisQ.REPEAT = false
			thisQ.Q._repeat = false

			local roomId = GetRoomMapByQueueID (qId) [1]
			if (roomId) then
				SetNextTrackURL ('', roomId)
				C4:SendToDevice (C4_DIGITAL_AUDIO, 'REPEAT', {ROOM_ID = roomId, REPEAT = ((thisQ.REPEAT and 1) or 0)})
			end
		end
		UpdateQueue (qId, {suppressList = true})
		UpdateDashboard (qId)
	end
end

function QueueSetShuffle (qId)
	local thisQ = SongQs [qId]

	if (thisQ) then
		if (not (thisQ.SHUFFLE or thisQ.STREAM or thisQ.RADIO)) then
			local roomId = GetRoomMapByQueueID (qId) [1]
			local newQ = {}
			local order = {}

			local inList = {}
			for i = 1, #thisQ.Q do inList [i] = i end

			if (thisQ.CurrentTrack and thisQ.Q [thisQ.CurrentTrack]) then
				local item = thisQ.Q [thisQ.CurrentTrack]
				table.insert (newQ, item)
				table.insert (order, thisQ.CurrentTrack)
				table.remove (inList, thisQ.CurrentTrack)
				thisQ.CurrentTrack = 1
			end
			if (#inList > 0) then
				repeat
					local r = math.random (1, #inList)
					local pos = inList [r]
					local item = thisQ.Q [pos]
					table.insert (newQ, item)
					table.insert (order, pos)
					table.remove (inList, r)
				until (#inList == 0)
			end

			thisQ.Q = newQ
			thisQ.SHUFFLE = order
			thisQ.Q._parent = thisQ
			setmetatable (thisQ.Q, REPEAT_METATABLE)

			local roomId = GetRoomMapByQueueID (qId) [1]
			if (roomId) then
				SetNextTrackURL ('', roomId)
				C4:SendToDevice (C4_DIGITAL_AUDIO, 'SHUFFLE', {ROOM_ID = roomId, SHUFFLE = ((thisQ.SHUFFLE and 1) or 0)})
			end
		end
		UpdateQueue (qId)
		UpdateDashboard (qId)
	end
end

function QueueClearShuffle (qId)
	local thisQ = SongQs [qId]

	if (thisQ) then
		if (not (not (thisQ.SHUFFLE) or thisQ.STREAM or thisQ.RADIO)) then

			thisQ.CurrentTrack = thisQ.SHUFFLE [thisQ.CurrentTrack]

			local newQ = {}

			for index, pos in pairs (thisQ.SHUFFLE) do
				newQ [pos] = thisQ.Q [index]
			end
			for i = #thisQ.SHUFFLE + 1, #thisQ.Q do
				newQ [i] = thisQ.Q [i]
			end

			thisQ.Q = newQ
			thisQ.SHUFFLE = nil
			thisQ.Q._parent = thisQ
			setmetatable (thisQ.Q, REPEAT_METATABLE)

			local roomId = GetRoomMapByQueueID (qId) [1]
			if (roomId) then
				SetNextTrackURL ('', roomId)
				C4:SendToDevice (C4_DIGITAL_AUDIO, 'SHUFFLE', {ROOM_ID = roomId, SHUFFLE = ((thisQ.SHUFFLE and 1) or 0)})
			end
		end
		UpdateQueue (qId)
		UpdateDashboard (qId)
	end
end

function Play (roomId)
	local qId = GetQueueIDByRoomID (roomId)
	local thisQ = SongQs [qId]

	if (thisQ and (thisQ.CurrentState == 'STOP' or thisQ.CurrentState == 'END')) then
		if (thisQ.RADIO) then
			GetNextProgrammedTrack (thisQ.RADIO, roomId)
		else
			local nextTrack = thisQ.Q [thisQ.CurrentTrack]
			if (nextTrack and roomId) then
				GetTrackURLAndPlay (nextTrack, roomId)
			end
		end
		return '<ret><handled>true</handled></ret>'
	end
end

function SkipFwd (roomId)
	local qId = GetQueueIDByRoomID (roomId)
	local thisQ = SongQs [qId]

	if (thisQ) then
		if (thisQ.RADIO) then
			if (thisQ.nextProgrammedTrackRequested) then return end
			if (thisQ.SKIPS >= MAX_SKIPS) then return end

			GetNextProgrammedTrack (thisQ.RADIO, roomId, 'SKIP')

			if (MAX_SKIPS ~= math.huge and type (SKIP_TIMEOUT) == 'number') then
				QueueRadioSkipManager (qId)
			end

			UpdateDashboard (qId)

		elseif (thisQ.STREAM) then

		else
			Skip (roomId, 1)
		end
	end
end

function SkipRev (roomId)
	local qId = GetQueueIDByRoomID (roomId)
	local thisQ = SongQs [qId]

	if (thisQ) then
		if (thisQ.STREAM) then return end
		if (thisQ.RADIO) then return end

		if (thisQ.CurrentTrackElapsed > 15 and thisQ.SKIP_INCREMENT == nil) then
			Skip (roomId, 0)
		else
			Skip (roomId, -1)
		end
	end
end

function Skip (roomId, increment)
	local qId = GetQueueIDByRoomID (roomId)
	local thisQ = SongQs [qId]

	if (thisQ) then
		thisQ.SKIP_INCREMENT = thisQ.SKIP_INCREMENT or 0
		thisQ.SKIP_INCREMENT = thisQ.SKIP_INCREMENT + increment

		if (not (thisQ.REPEAT)) then
			local newPos = thisQ.CurrentTrack + thisQ.SKIP_INCREMENT
			if (newPos > #thisQ.Q or newPos < 1) then
				thisQ.SKIP_INCREMENT = thisQ.SKIP_INCREMENT - increment	-- stop from skipping past end or beginning of queue if not on repeat
				return
			end
		end

		local _timer = function (timer)
			thisQ.SKIP_INCREMENT = thisQ.SKIP_INCREMENT or 0

			local nextTrack = thisQ.Q [thisQ.CurrentTrack + thisQ.SKIP_INCREMENT]

			local strCommand = (thisQ.SKIP_INCREMENT > 0 and 'SKIP_FWD') or (thisQ.SKIP_INCREMENT < 0 and 'SKIP_REV') or 'REPLAY'

			thisQ.SKIP_INCREMENT = nil
			thisQ.SKIP_INCREMENT_TIMER = CancelTimer (thisQ.SKIP_INCREMENT_TIMER)

			LogPlayEvent ('user', qId, strCommand, nextTrack)

			if (nextTrack and roomId) then
				GetTrackURLAndPlay (nextTrack, roomId)
			end
		end

		thisQ.SKIP_INCREMENT_TIMER = SetTimer (thisQ.SKIP_INCREMENT_TIMER, 500, _timer)
		UpdateQueue (qId, {suppressList = true})
	end
end

function Seek (roomId, pos, seekType)
	if (not (roomId and pos and seekType)) then
		return
	end

	local qId = GetQueueIDByRoomID (roomId)

	local thisQ = SongQs [qId]

	if (not thisQ) then
		print ('Cannot seek, no queue')
		return
	end

	local elapsed = thisQ.CurrentTrackElapsed
	local duration = thisQ.CurrentTrackDuration

	if (not (elapsed and duration)) then
		return
	end

	if (not (SUPPORTS_SEEK_ABSOLUTE)) then
		if (seekType == 'absolute') then
			pos = pos - elapsed
			seekType = 'relative'
		elseif (seekType == 'percent') then
			local target = math.floor (duration * (pos / 100))
			pos = target - elapsed
			seekType = 'relative'
		end
	end

	local target
	if (seekType == 'absolute') then
		target = pos
	elseif (seekType == 'relative') then
		target = elapsed + pos
	elseif (seekType == 'percent') then
		target = math.floor (duration * (pos / 100))
	end

	if (not target) then
		print ('Cannot seek, could not calculate target position')
		return
	end

	if (target < 0) then
		print ('Cannot seek, target is before start of track')
		return
	end

	if (target > duration) then
		print ('Cannot seek, target is after end of track')
		return
	end

	if (roomId and pos and seekType) then
		local _args = {
			ROOM_ID = roomId,
			POSITION = pos * 1000, -- convert seconds to ms
			TYPE = seekType,
		}

		C4:SendToDevice (C4_DIGITAL_AUDIO, 'SEEK', _args)

		if (seekType == 'absolute') then
			thisQ.CurrentTrackElapsed = pos
		elseif (seekType == 'relative') then
			thisQ.CurrentTrackElapsed = thisQ.CurrentTrackElapsed + pos
		elseif (seekType == 'percent') then
			thisQ.CurrentTrackElapsed = math.floor (thisQ.CurrentTrackDuration * (pos / 100))
		end

		UpdateProgress (qId)

		return '<ret><handled>true</handled></ret>'
	end
end

function RegisterRooms ()
	RoomIDs = C4:GetDevicesByC4iName ('roomdevice.c4i')
	RoomIDSources = {}
	RoomIDPlayingSources = {}
	RoomIDDigitalMedia = {}
	RoomIDRoutes = {}
	for roomId, _ in pairs (RoomIDs) do
		RegisterVariableListener (roomId, ROOM_VARS.CURRENT_SELECTED_DEVICE, OWVC.ParseRoomIdSource)
		RegisterVariableListener (roomId, ROOM_VARS.CURRENT_AUDIO_PATH, OWVC.ParseRoomIdRoute)
		RegisterVariableListener (roomId, ROOM_VARS.PLAYING_AUDIO_DEVICE, OWVC.ParseRoomIdPlayingSource)
	end
end

function GetQueueIDByRoomID (roomId)
	roomId = tonumber (roomId)
	local qId = RoomQIDMap [roomId] or 0
	local queue = QueueMap [qId] or {}
	return qId, queue
end

function GetRoomMapByQueueID (qId)
	qId = tonumber (qId)
	local queue = QueueMap [qId] or {}
	return (queue)
end

function GetDashboardByQueue (qId)
	qId = tonumber (qId)
	local thisQ = SongQs [qId]
	if (thisQ) then
		local dashboard = {}
		if (SUPPORTS_CUSTOM_DASH) then
			if (not (thisQ.RADIO or thisQ.STREAM)) then
				if (thisQ.SHUFFLE ~= nil) then
					table.insert (dashboard, 'ShuffleOff')
				else
					table.insert (dashboard, 'ShuffleOn')
				end
			end
			if (thisQ.nowPlayingTags.can_thumbs_down) then
				table.insert (dashboard, 'ThumbsDown')
			elseif (thisQ.nowPlayingTags.can_thumbs_down_cancel) then
				table.insert (dashboard, 'ThumbsDownCancel')
			end
		end

		if (#thisQ.Q > 0 and not (thisQ.RADIO or thisQ.STREAM)) then
			table.insert (dashboard, 'SkipRev')
		end

		if (thisQ.CurrentState == 'PLAY') then
			if (thisQ.STREAM) then
				table.insert (dashboard, 'Stop')
			else
				table.insert (dashboard, 'Pause')
			end

		elseif (thisQ.CurrentState == 'PAUSE') then
			table.insert (dashboard, 'Play')

		elseif ((thisQ.CurrentState == 'STOP' or thisQ.CurrentState == 'END') and (#thisQ.Q > 0 or thisQ.STREAM)) then
			table.insert (dashboard, 'Play')
		end

		if (((thisQ.RADIO and thisQ.SKIPS < MAX_SKIPS) or (thisQ.CurrentTrack and (thisQ.REPEAT or thisQ.CurrentTrack < #thisQ.Q))) and not thisQ.STREAM) then
			table.insert (dashboard, 'SkipFwd')
		end

		if (SUPPORTS_CUSTOM_DASH) then
			if (not (thisQ.RADIO or thisQ.STREAM)) then
				if (thisQ.REPEAT == true) then
					table.insert (dashboard, 'RepeatOff')
				else
					table.insert (dashboard, 'RepeatOn')
				end
			end
			if (thisQ.nowPlayingTags.can_thumbs_up) then
				table.insert (dashboard, 'ThumbsUp')
			elseif (thisQ.nowPlayingTags.can_thumbs_up_cancel) then
				table.insert (dashboard, 'ThumbsUpCancel')
			end
		end

		dashboard = table.concat (dashboard, ' ')

		thisQ.dashboard = dashboard
		return dashboard
	end
end

function GetNowPlayingTagsByQueue (qId)
	qId = tonumber (qId)
	local thisQ = SongQs [qId]

	if (thisQ) then
		local nowPlayingTags = CopyTable (thisQ.nowPlayingTags or {})

		nowPlayingTags.shuffle_on = tostring (thisQ.SHUFFLE ~= nil)
		nowPlayingTags.repeat_on = tostring (thisQ.REPEAT == true)

		nowPlayingTags.actions_list = nowPlayingTags.actions_list or DEFAULT_QUEUE_ACTIONS_LIST

		if (SUPPORTS_CUSTOM_DASH) then
			nowPlayingTags.can_shuffle = 'false'
			nowPlayingTags.can_repeat = 'false'
			nowPlayingTags.shuffle_on = 'false'
			nowPlayingTags.repeat_on = 'false'

			nowPlayingTags.can_thumbs_up = 'false'
			nowPlayingTags.can_thumbs_up_cancel = 'false'
			nowPlayingTags.can_thumbs_down = 'false'
			nowPlayingTags.can_thumbs_down_cancel = 'false'

			if (nowPlayingTags.actions_list) then
				for i = #nowPlayingTags.actions_list, 1, -1 do
					local action = nowPlayingTags.actions_list [i]
					if (CUSTOM_DASH_ACTIONS [action]) then
						table.remove (nowPlayingTags.actions_list, i)
					end
				end
			end
		end

		if (nowPlayingTags.actions_list) then
			nowPlayingTags.actions_list = table.concat (nowPlayingTags.actions_list, ' ')
		end

		return (XMLTag (nowPlayingTags))
	end
end

-- Force single queue
function GetMasterRoom (deviceId)
	if (deviceId == nil) then
		deviceId = PROXY_ID
	end
	for qId, qInfo in pairs (QueueMap) do
		if (qInfo.source == deviceId) then
			return qInfo.ownerId, qInfo
		end
	end
	return nil, {}
end

function JoinRoomToSession (roomId, qId)
	if (CheckRoomHasDigitalAudio (roomId) == false) then
		dbg ('Tried to join digital audio session with room with no Digital Audio:', roomId)
		--return
	end

	if (qId == nil) then
		local masterRoom, masterQueueInfo = GetMasterRoom ()
		if (masterQueueInfo.qId) then
			qId = masterQueueInfo.qId
		else
			return
		end
	end

	local sessionQueue = GetRoomMapByQueueID (qId)
	local _, roomQueue = GetQueueIDByRoomID (roomId)

	if (sessionQueue.ownerId) then
		if (sessionQueue~= roomQueue) then
			local args = {
				ROOM_ID = sessionQueue.ownerId,
				ROOM_ID_LIST = roomId,
			}
			C4:SendToDevice (C4_DIGITAL_AUDIO, 'ADD_ROOMS_TO_SESSION', args)
		end
		return true
	end
end

function CheckRoomHasDigitalAudio (roomId)
	roomId = tonumber (roomId)
	if (roomId == nil) then
		return false
	end
	C4_DIGITAL_AUDIO = next (C4:GetDevicesByC4iName ('control4_digitalaudio.c4i'))
	local hasC4DA = false
	if (C4_DIGITAL_AUDIO) then
		local listenSources = C4:SendToDevice (roomId, 'GET_LISTEN_DEVICES', {})
		hasC4DA = (string.find (listenSources, tostring (C4_DIGITAL_AUDIO)) ~= nil)
	end

	if (hasC4DA == false) then
		MetricsMSP:SetCounter ('Error_NoDigitalAudio')
	end

	return (hasC4DA)
end

-- Update Navigator
function MakeList (response, collection, options)
	if (not options) then
		options = {}
	end
	if (collection) then
		collection.image_list = MakeImageList (collection)
		if (SUPPORTS_DEFAULT_AND_ACTIONS and options.makeDefaultAction) then
			if (collection.actions_list and not (collection.default_action)) then
				local firstAction = string.match (collection.actions_list, '(%w+)')
				if (firstAction) then
					collection.default_action = firstAction
				end
			end
		end
		collection = XMLTag (collection)
	end

	local list = {}
	for _, item in ipairs (response) do
		if (options.suppressItemImages) then
			item.image_list = nil
		else
			item.image_list = MakeImageList (item)
		end
		if (options and options.defaults) then
			for k, v in pairs (options.defaults) do
				if (item [k] == nil) then
					item [k] = v
				end
			end
		end
		if (SUPPORTS_DEFAULT_AND_ACTIONS and options.makeDefaultAction) then
			if (item.actions_list and not (item.default_action)) then
				local firstAction = string.match (item.actions_list, '(%w+)')
				if (firstAction) then
					item.default_action = firstAction
				end
			end
		end
		table.insert (list, XMLTag ('item', item))
	end

	list = table.concat (list)

	if (response.totalCount) then
		if (MAX_LIST_SIZE and response.totalCount > MAX_LIST_SIZE) then
			response.totalCount = MAX_LIST_SIZE
		end
		return ({Collection = collection, ['List length="' .. response.totalCount .. '"'] = list})
	else
		return ({Collection = collection, List = list})
	end
end

function UpdateMediaInfo (qId)
	local thisQ = SongQs [qId]

	if (thisQ) then
		local thisTrack = thisQ.Q [thisQ.CurrentTrack] or {}

		local args = {
			TITLE = thisTrack.title,
			ALBUM = thisTrack.album,
			ARTIST = thisTrack.artist,
			GENRE = thisTrack.genre,
			IMAGEURL = thisTrack.image,
			QUEUEID = qId,
			}
		C4:SendToProxy (MSP_PROXY, 'UPDATE_MEDIA_INFO', args, 'COMMAND', true)
	end
end

function UpdateQueue (qId, options)
	if (type (options) ~= 'table') then
		options = {}
	end

	local thisQ = SongQs [qId]

	if (thisQ and GetRoomMapByQueueID (qId) [1]) then
		local rooms = GetRoomMapByQueueID (qId)
		rooms = table.concat (rooms, ',')

		local index = thisQ.CurrentTrack

		local start, finish

		local surround = QUEUE_WINDOW_HALF

		start = index - surround
		if (start < 1) then
			surround = surround + (1 - start)
			start = 1
		end

		finish = index + surround
		if (finish > #thisQ.Q) then
			start = start - (finish - #thisQ.Q)
			if (start < 1) then
				start = 1
			end
			finish = #thisQ.Q
		end

		index = index - start + 1 + (thisQ.SKIP_INCREMENT or 0)

		local list = {}
		for i = start, finish do
			local item = thisQ.Q [i]

			if (SUPPORTS_DEFAULT_AND_ACTIONS) then
				if (item.default_action == nil) then
					if (string.find (item.actions_list or '', '^QueueSelect')) then
						item.default_action = 'QueueSelect'
					end
				end
			end

			table.insert (list, XMLTag ('item', item))
		end
		list = table.concat (list)

		if (options.forceRefreshList) then
			thisQ.LastQueueList = list

		elseif (options.suppressList) then
			list = nil

		elseif (list and list == thisQ.LastQueueList) then
			list = nil

		else
			thisQ.LastQueueList = list
		end

		local event = {
			NowPlaying = GetNowPlayingTagsByQueue (qId),
			NowPlayingIndex = index - 1, -- this is a 0 indexed list for some reason
			List = list,
		}

		SendEvent (MSP_PROXY, nil, rooms, 'QueueChanged', event)
	end
end

function UpdateDashboard (qId)
	local thisQ = SongQs [qId]

	if (thisQ and GetRoomMapByQueueID (qId) [1]) then
		local dashboard = GetDashboardByQueue (qId)
		local rooms = GetRoomMapByQueueID (qId)
		rooms = table.concat (rooms, ',')

		SendEvent (MSP_PROXY, nil, rooms, 'DashboardChanged', {QueueId = qId, Items = dashboard})
	end
end

function UpdateProgress (qId)
	local thisQ = SongQs [qId]
	if (thisQ and GetRoomMapByQueueID (qId) [1]) then
		local rooms = GetRoomMapByQueueID (qId)
		rooms = table.concat (rooms, ',')

		local args

		if (UPDATE_FREQ) then
			if (thisQ.STREAM) then
				args = {
					length = 1,
					offset = 1,
					label = GetTimeString (thisQ.CurrentTrackElapsed),
					canSeek = false,
				}
			else
				local elapsed = GetTimeNumber (thisQ.CurrentTrackElapsed)
				local duration = GetTimeNumber (thisQ.CurrentTrackDuration)
				local remaining = duration - elapsed

				local remainingString = GetTimeString (remaining)
				local elapsedString = GetTimeString (thisQ.CurrentTrackElapsed)

				args = {
					length = GetTimeNumber (thisQ.CurrentTrackDuration),
					offset = GetTimeNumber (thisQ.CurrentTrackElapsed),
					label = elapsedString .. ' / -' .. remainingString,
					canSeek = true,
				}
				SendEvent (MSP_PROXY, nil, rooms, 'ProgressChanged', args)
			end
		else
			args = {
				length = 0,
				offset = 0,
				label = '',
				canSeek = false,
			}
		end

		if (args) then
			SendEvent (MSP_PROXY, nil, rooms, 'ProgressChanged', args)
		end
	end
end

-- Queue State Changes
function OnInternetRadioSelected (idBinding, tParams)
	local qId = tonumber (tParams.QUEUE_ID)
	local queueInfo = tonumber (tParams.QUEUE_INFO)

	local roomId = tonumber (tParams.ROOM_ID)
	local stationUrl = tParams.STATION_URL

	local thisQ = SongQs [qId]
end

function OnInternetRadioSelectedError (idBinding, tParams)
	local queueInfo = tonumber (tParams.QUEUE_INFO)

	local roomId = tonumber (tParams.ROOM_ID)
	local stationUrl = tParams.STATION_URL
	MetricsMSP:SetCounter ('Error_OnInternetRadioSelected')
end

function OnQueueDeleted (idBinding, tParams)
	local qId = tonumber (tParams.QUEUE_ID)
	local queueInfo = tonumber (tParams.QUEUE_INFO)

	local lastState = tParams.LAST_STATE
	local lastStateTime = tParams.LAST_STATE_TIME

	local stateParams = {
		QUEUE_ID = tParams.QUEUE_ID,
		QUEUE_INFO = tParams.QUEUE_INFO,
		STATE = 'STOP',
	}
	OnQueueStateChanged (idBinding, stateParams)

	local thisQ = SongQs [qId]

	LogPlayEvent ('queue', qId, 'DELETED')

	SongQs [qId] = nil
	MetricsMSP:SetCounter ('QueueDeleted')
	MetricsMSP:SetGauge ('QueueCount', GetTableSize (SongQs))
end

function OnQueueInfoChanged (idBinding, tParams)
	local qId = tonumber (tParams.QUEUE_ID)
	local queueInfo = tonumber (tParams.QUEUE_INFO)

	local state = tParams.QUEUE_STATE
	local stateTime = tonumber (tParams.QUEUE_STATE_TIME)

	local thisQ = SongQs [qId]
end

function OnQueueMediaInfoUpdated (idBinding, tParams)
	local qId = tonumber (tParams.QUEUE_ID)
	local queueInfo = tonumber (tParams.QUEUE_INFO)

	local mediaInfo = tParams.MEDIA_INFO

	local thisQ = SongQs [qId]
end

function OnQueueNeedNext (idBinding, tParams)
	local qId = tonumber (tParams.QUEUE_ID)
	local queueInfo = tonumber (tParams.QUEUE_INFO)

	local thisQ = SongQs [qId]

	if (thisQ) then
		if (thisQ.STREAM) then
			return
		end

		local nextTrack = thisQ.Q [thisQ.CurrentTrack + 1]

		if (thisQ.RADIO) then
			nextTrack = thisQ.RADIO_NEXT_TRACK
			nextTrack.idInQ = thisQ.idInQ
			thisQ.idInQ = thisQ.idInQ + 1
			nextTrack.image_list = MakeImageList (nextTrack)
			thisQ.RADIO_NEXT_TRACK = nil
			table.insert (thisQ.Q, nextTrack)
		end

		thisQ.CurrentTrackElapsed = GetTimeNumber (thisQ.Q [thisQ.CurrentTrack].duration)

		LogPlayEvent ('queue', qId, 'END', nextTrack)

		if (nextTrack) then
			thisQ.trackStartEvented = false
			thisQ.trackStopEvented = false
			thisQ.trackStarted = os.time ()
			thisQ.nextUrlSent = false
			thisQ.nextUrlRequested = false
			thisQ.nextProgrammedTrackRequested = false
			thisQ.CurrentTrackElapsed = 0
			thisQ.ProgressTimer = CancelTimer (thisQ.ProgressTimer)

			if (nextTrack.idInQ ~= nil) then
				for i, track in ipairs (thisQ.Q) do
					if (nextTrack.idInQ == track.idInQ) then
						thisQ.CurrentTrack = i
					end
				end
			end

			local params = {
				QUEUE_ID = qId,
				STATE = 'PLAY',
				PREV_STATE = 'NEXT',
				QUEUE_INFO = nextTrack.idInQ,
			}

			OnQueueStateChanged (idBinding, params)
		end
	end
end

function OnQueueStateChanged (idBinding, tParams)
	local qId = tonumber (tParams.QUEUE_ID)
	local queueInfo = tonumber (tParams.QUEUE_INFO)

	local currentState = tParams.STATE
	local previousState = tParams.PREV_STATE

	local thisQ = SongQs [qId]

	if (not thisQ) then
		for _, roomId in ipairs (GetRoomMapByQueueID (qId)) do
			if (SongQs [roomId]) then
				SongQs [qId] = SongQs [roomId]
				SongQs [roomId] = nil
				thisQ = SongQs [qId]
				thisQ.Q._parent = thisQ
				setmetatable (thisQ.Q, REPEAT_METATABLE)
				MetricsMSP:SetCounter ('NewQueueComplete')
				MetricsMSP:SetGauge ('QueueCount', GetTableSize (SongQs))
			end
		end
	end

	local roomId = GetRoomMapByQueueID (qId) [1]

	if (thisQ) then
		thisQ.CurrentState = currentState
		thisQ.PreviousState = previousState

		local thisTrack = thisQ.Q [thisQ.CurrentTrack] or {}
		thisQ.CurrentTrackDuration = GetTimeNumber (thisTrack.duration)

		thisQ.ProgressTimer = CancelTimer (thisQ.ProgressTimer)

		if (thisQ.CurrentState == 'PLAY') then
			LogPlayEvent ('queue', qId, 'PLAY')

			local _timer = function (timer)
				thisQ.CurrentTrackElapsed = thisQ.CurrentTrackElapsed + 1
				if (UPDATE_FREQ and thisQ.CurrentTrackElapsed % UPDATE_FREQ == 0) then
					UpdateProgress (qId)
				end

				if (ProgressMonitor and type (ProgressMonitor) == 'function') then
					local success, ret = pcall (ProgressMonitor, qId)
					if (success) then
						if (ret) then
						end
					else
						dbg ('ProgressMonitor: an error occured: ' .. ret)
					end
				end

				if (SUPPORTS_GAPLESS and thisQ.CurrentTrackElapsed + 15 >= thisQ.CurrentTrackDuration and thisQ.CurrentTrackDuration ~= 0) then
					if (not (thisQ.nextUrlRequested or thisQ.nextUrlSent)) then
						if (thisQ.STREAM) then
						elseif (thisQ.RADIO) then
							GetFutureProgrammedTrack (thisQ.RADIO, roomId)
						else
							local nextTrack = thisQ.Q [thisQ.CurrentTrack + 1]
							if (nextTrack) then
								GetFutureTrackURL (nextTrack, roomId)
							end
						end
					end
				end
			end

			thisQ.ProgressTimer = SetTimer (thisQ.ProgressTimer, ONE_SECOND, _timer, true)

		elseif (thisQ.CurrentState == 'PAUSE') then
			LogPlayEvent ('queue', qId, 'PAUSE')

		elseif (thisQ.CurrentState == 'STOP') then
			LogPlayEvent ('queue', qId, 'STOP')
			thisQ.CurrentTrackElapsed = 0

		elseif (thisQ.CurrentState == 'END') then
			thisQ.CurrentTrackElapsed = thisQ.CurrentTrackDuration

			local roomId = GetRoomMapByQueueID (qId) [1]

			if (thisQ.STREAM) then
				LogPlayEvent ('queue', qId, 'END')

			elseif (thisQ.RADIO and roomId) then
				GetNextProgrammedTrack (thisQ.RADIO, roomId, 'TRACK_END')
				LogPlayEvent ('queue', qId, 'END')

			else
				local nextTrack = thisQ.Q [thisQ.CurrentTrack + 1]

				LogPlayEvent ('queue', qId, 'END', nextTrack)

				if (nextTrack == nil) then
					thisQ.CurrentTrack = 1
				end

				if (nextTrack and roomId) then
					GetTrackURLAndPlay (nextTrack, roomId)
				end
			end
		end

		UpdateDashboard (qId)
		UpdateProgress (qId)
		UpdateMediaInfo (qId)
		UpdateQueue (qId)
	end
end

function OnQueueStreamStatusChanged (idBinding, tParams)
	local qId = tonumber (tParams.QUEUE_ID)
	local queueInfo = tonumber (tParams.QUEUE_INFO)

	local status = ParseQueueStreamStatus (tParams.STATUS) or {}
	local thisQ = SongQs [qId]

	if (thisQ) then
		if (status.status) then
			local statusChange
			if (thisQ.StreamStatus ~= status.status) then
				thisQ.StreamStatus = status.status
				statusChange = true
			end
			if (statusChange or status.status ~= 'OK_playing') then
				MetricsMSP:SetCounter ('QueueStreamStatus_' .. status.status)
			end
		end
	end
end

function ParseQueueStreamStatus (status)
	local escapes = {}

	local escape = function (esc)
		if (not escapes [esc]) then
			table.insert (escapes, esc)
			escapes [esc] = '~!@' .. #escapes .. '@!~'
		end
		return (escapes [esc])
	end

	status = string.gsub (status, '\\(.)', escape)

	if (string.sub (status, -1, -1) ~= ',') then status = status .. ',' end

	local pos = 1

	local ret = {}

	while (pos < string.len (status)) do
		local startOfKey = pos
		local endOfKey = string.find (status, '=', startOfKey)

		local key = string.sub (status, startOfKey, endOfKey - 1)

		local startOfValue = endOfKey + 1
		local endOfValue

		if (string.sub (status, startOfValue, startOfValue) == '"') then
			startOfValue = startOfValue + 1
			endOfValue = string.find (status, '",', startOfValue)
			pos = endOfValue + 2
		else
			endOfValue = string.find (status, ',', startOfValue)
			pos = endOfValue + 1
		end

		local value = string.sub (status, startOfValue, endOfValue - 1)

		value = string.match (value, '^%s*(.-)%s*$')
		if (value == '') then value = nil end

		ret [key] = value
	end

	for k, v in pairs (CopyTable (ret)) do
		ret [k] = string.gsub (v, '~!@(.-)@!~', function (a) return (escapes [tonumber (a)]) end)

		if (k == 'title') then
			local newTitle
			if (string.find (ret [k], '^{')) then
				newTitle = JSON:decode (ret [k])

			elseif (string.find (ret [k], '",')) then
				newTitle = ParseQueueStreamStatus (ret [k])
			end

			for a, b in pairs (newTitle or {}) do
				if (ret [a]) then
					ret ['orig_' .. a] = ret [a]
				end
				ret [a] = b
			end
		end
	end

	return ret
end

function AttemptToLogin ()
	if (PersistData.AuthSettings.username and PersistData.AuthSettings.password) then
		local username = PersistData.AuthSettings.username
		local password = C4:Decrypt ('AES-256-CBC', C4:GetDriverConfigInfo ('model'), nil, PersistData.AuthSettings.password, AES_DEC_DEFAULTS)
		if (username and password) then
			Login (username, password)
		end
	end
end

---------------------
-- IMPLEMENT THESE --
---------------------
function ProgressMonitor (qId)
	local thisQ = SongQs [qId]
	if (thisQ) then
		local track = thisQ.Q [thisQ.CurrentTrack]
	end
end

function GetFutureProgrammedTrack (program, roomId)
	if (program == nil or roomId == nil) then return end

	local qId = GetQueueIDByRoomID (roomId)
	local thisQ = SongQs [qId]

	if (thisQ) then
		thisQ.nextUrlRequested = true
	end

	-- retrieve next track in program and set to thisQ.RADIO_NEXT_TRACK, then pull URL and set with SetNextTrackURL
	-- on error thisQ.nextUrlRequested = false
end

function GetFutureTrackURL (track, roomId)
	if (track == nil or roomId == nil) then return end

	local qId = GetQueueIDByRoomID (roomId)
	local thisQ = SongQs [qId]

	if (thisQ) then
		thisQ.nextUrlRequested = true
	end
	-- retrieve URL of track, set as next using SetNextTrackURL (url, roomId, flags)
	-- on error thisQ.nextUrlRequested = false
end

function GetNextProgrammedTrack (program, roomId, reason)
	local qId = GetQueueIDByRoomID (roomId)
	local thisQ = SongQs [qId]

	if (thisQ) then
		thisQ.nextProgrammedTrackRequested = true
	end

	if (reason == 'SKIP') then
	elseif (reason == 'TRACK_END') then
	end

	-- retrieve next track details, add to queue and play with RADIO_NEXT playOption
end

function GetTrackURLAndPlay (track, roomId)
	-- retrieve URL of track, play using PlayTrackURL (url, roomId, idInQ, flags) - idInQ value present in track object
end

function LogPlayEvent (source, qId, event, nextTrack)
	local thisQ = SongQs [qId]
	if (thisQ == nil) then
		print ('Attempted to Log Play Event on unknown queue:', source, qId, event, nextTrack)
		return
	end

	local roomId = GetRoomMapByQueueID (qId) [1]
	if (roomId == nil) then
		print ('Logging play event on nil room', source, qId, event, nextTrack)
	end

	local thisTrack = thisQ.Q [thisQ.CurrentTrack]
	if (thisTrack == nil) then
		print ('Logging play event on nil track', source, qId, event, nextTrack)
	end

	if (source == 'user') then
		if (event == 'PLAY') then 						-- generates matching queue event
		elseif (event == 'PAUSE') then 					-- generates matching queue event
		elseif (event == 'STOP') then 					-- generates matching queue event
		elseif (event == 'REPLAY') then					-- current track will stop prematurely and not get a queue event
		elseif (event == 'SKIP_FWD') then 				-- current track will stop prematurely and not get a queue event
		elseif (event == 'SKIP_REV') then				-- current track will stop prematurely and not get a queue event
		elseif (event == 'QUEUE_SELECT') then			-- current track will stop prematurely and not get a queue event
		elseif (event == 'NEW_TRACKS_ADDED') then		-- current track will stop prematurely and not get a queue event
		end

	elseif (source == 'queue') then
		if (event == 'PLAY') then
			if (thisQ.trackStartEvented == false) then	--first PLAY event we have on track
				thisQ.trackStartEvented = true
			end
		elseif (event == 'PAUSE') then
		elseif (event == 'STOP') then
		elseif (event == 'END') then
		elseif (event == 'DELETED') then
		end
	end

	-- thisQ.trackStartEvented and thisQ.trackStopEvented useful here
end

function MakeImageList (item, tag)
	if (item.image_list) then
		return (item.image_list)
	end
	local image_list = {}

	tag = tag or 'image_list'

	--table.insert (image_list, '<' .. tag .. ' width="' .. width .. '" height="' .. height .. '">' .. imageUrl .. '</' .. tag .. '>')
	return (image_list)
end

function QueueRadioSkipManager (qId)
	local thisQ = SongQs [qId]
	if (thisQ and thisQ.SKIPS) then
		thisQ.SKIPS = thisQ.SKIPS + 1
	end

	local _timer = function (timer)
		local thisQ = SongQs [qId]
		if (thisQ and thisQ.SKIPS) then
			thisQ.SKIPS = thisQ.SKIPS - 1
			if (thisQ.SKIPS < 0) then
				thisQ.SKIPS = 0
			end
			UpdateDashboard (qId)
		end
	end
	SetTimer (nil, SKIP_TIMEOUT, _timer)
end

function SelectDefaultItemInRoom (roomId)
end

function SelectMediaDBItemInRoom (itemId, roomId)
end

-----------------
--- Navigator ---
-----------------
function Navigator:new (navId)
	local n = {
		navId = navId,
		roomId = 0,
		AuthSettings = {},
	}

	if (PersistData and PersistData.AuthSettings) then
		for k, v in pairs (PersistData.AuthSettings) do
			n.AuthSettings [k] = v
		end
	end

	setmetatable (n, self)
	self.__index = self

	return n
end

function Navigator:urlDo (idBinding, seq, method, url, data, headers, callback, context, options)
	local navTicketHandler = function (strError, responseCode, tHeaders, data, context, url)
		local func = self [callback]
		local success, ret = pcall (func, self, idBinding, seq, strError, responseCode, tHeaders, data, context, url)
		if (success) then
			if (ret) then
				DataReceived (idBinding, self.navId, seq, ret)
			end
		else
			dbg ('Navigator URL error occured: ' .. ret)
			DataReceivedError (idBinding, self.navId, seq, ret)
		end
	end

	urlDo (method, url, data, headers, navTicketHandler, context, options)
end

function Navigator:urlGet (idBinding, seq, url, headers, callback, context, options)
	self:urlDo (idBinding, seq, 'GET', url, data, headers, callback, context, options)
end

function Navigator:urlPost (idBinding, seq, url, data, headers, callback, context, options)
	self:urlDo (idBinding, seq, 'POST', url, data, headers, callback, context, options)
end

function Navigator:urlPut (idBinding, seq, url, data, headers, callback, context, options)
	self:urlDo (idBinding, seq, 'PUT', url, data, headers, callback, context, options)
end

function Navigator:urlDelete (idBinding, seq, url, headers, callback, context, options)
	self:urlDo (idBinding, seq, 'DELETE', url, data, headers, callback, context, options)
end

function Navigator:urlCustom (idBinding, seq, url, method, data, headers, callback, context, options)
	self:urlDo (idBinding, seq, method, url, data, headers, callback, context, options)
end

function Navigator:GetDashboard (idBinding, seq, args)
	local qId = GetQueueIDByRoomID (self.roomId)
	UpdateDashboard (qId)
	return ('')
end

function Navigator:GetQueue (idBinding, seq, args)
	local qId = GetQueueIDByRoomID (self.roomId)
	UpdateQueue (qId, {forceRefreshList = true})
	return ('')
end

function Navigator:QueueSelect (idBinding, seq, args)
	local qId = GetQueueIDByRoomID (self.roomId)
	local thisQ = SongQs [qId]

	if (thisQ) then
		if (thisQ.STREAM) then return end
		if (thisQ.RADIO) then return end

		local idInQ = tonumber (args.idInQ)
		local nextTrack

		if (idInQ ~= nil) then
			for _, track in ipairs (thisQ.Q) do
				if (track.idInQ == idInQ) then
					nextTrack = track
				end
			end
		end

		if (nextTrack and self.roomId) then
			LogPlayEvent ('user', qId, 'QUEUE_SELECT', nextTrack)
			GetTrackURLAndPlay (nextTrack, self.roomId)
		end
	end
	return ('')
end

function Navigator:RemoveFromQueue (idBinding, seq, args)
	local qId = GetQueueIDByRoomID (self.roomId)
	local thisQ = SongQs [qId]

	if (thisQ) then
		local idInQ = tonumber (args.idInQ)
		local nextTrack

		for index, track in ipairs (thisQ.Q) do
			if (track.idInQ == idInQ) then
				if (thisQ.SHUFFLE) then
					local pos = thisQ.SHUFFLE [index]
					table.remove (thisQ.SHUFFLE, index)
					for shuffledPos, originalPos in pairs (thisQ.SHUFFLE) do
						if (originalPos > pos) then
							thisQ.SHUFFLE [shuffledPos] = thisQ.SHUFFLE [shuffledPos] - 1
						end
					end
				end

				local changeTrack = thisQ.CurrentTrack == index
				local nextTrack

				if (changeTrack) then
					nextTrack = thisQ.Q [thisQ.CurrentTrack + 1]
					if (nextTrack == thisQ.Q [thisQ.CurrentTrack]) then
						nextTrack = nil
					end
					LogPlayEvent ('user', qId, 'SKIP_FWD', nextTrack)
				end

				table.remove (thisQ.Q, index)

				if (index <= thisQ.CurrentTrack) then
					thisQ.CurrentTrack = thisQ.CurrentTrack - 1
				end

				UpdateQueue (qId)

				if (changeTrack) then
					if (nextTrack) then
						GetTrackURLAndPlay (nextTrack, self.roomId)
					else
						C4:SendToDevice (self.roomId, 'STOP', {})
					end
				end
			end
		end
	end
	return ('')
end

function Navigator:SKIP_FWD (idBinding, seq, args)
	SkipFwd (self.roomId)
	return ('')
end

function Navigator:SKIP_REV (idBinding, seq, args)
	SkipRev (self.roomId)
	return ('')
end

function Navigator:ToggleShuffle (idBinding, seq, args)
	local qId = GetQueueIDByRoomID (self.roomId)
	local thisQ = SongQs [qId]

	if (thisQ) then
		if (thisQ.SHUFFLE) then
			QueueClearShuffle (qId)
		else
			QueueSetShuffle (qId)
		end
	end
	return ('')
end

function Navigator:ToggleRepeat (idBinding, seq, args)
	local qId = GetQueueIDByRoomID (self.roomId)
	local thisQ = SongQs [qId]

	if (thisQ) then
		if (thisQ.REPEAT) then
			QueueClearRepeat (qId)
		else
			QueueSetRepeat (qId)
		end
	end
	return ('')
end

function Navigator:GetSettingsScreen (idBinding, seq, args)
	local screenId = (LOGGED_IN and 'LoggedInScreen') or 'SettingsScreen'
	self.screenId = screenId
	return ({NextScreen = screenId})
end

function Navigator:CancelAuthenticationRequired (idBinding, seq, args)
	for roomId, deviceId in pairs (RoomIDDigitalMedia) do
		if (deviceId == PROXY_ID) then
			C4:SendToDevice (roomId, 'ROOM_OFF', {})
		end
	end

	return ({NextScreen = '#home'})
end

function Navigator:CancelAuthenticationInformation (idBinding, seq, args)
	for roomId, deviceId in pairs (RoomIDDigitalMedia) do
		if (deviceId == PROXY_ID) then
			C4:SendToDevice (roomId, 'ROOM_OFF', {})
		end
	end

	CancelTimer (APIAuth.Timer.CheckState)
	CancelTimer (APIAuth.Timer.GetCodeStatusExpired)

	UpdateAPIAuthLink ('')

	return ({NextScreen = '#home'})
end

function Navigator:ConfirmAuthenticationRequired (idBinding, seq, args)
	return ({['NextScreen tabId="Settings"'] = 'SettingsScreen'})
end

function Navigator:CancelAuthenticationComplete (idBinding, seq, args)
	CancelTimer ('AuthenticationComplete')

	local params = {
		Id = 'AuthenticationComplete',
		InstanceId = self.navId,
	}
	SendEvent (MSP_PROXY, self.navId, nil, 'CloseDriverNotification', params)

	return ({['NextScreen tabId="' .. HomeTabId .. '"'] = HomeScreenId})
end

function Navigator:ConfirmAuthenticationComplete (idBinding, seq, args)
	CancelTimer ('AuthenticationComplete')

	local params = {
		Id = 'AuthenticationComplete',
		InstanceId = self.navId,
	}
	SendEvent (MSP_PROXY, self.navId, nil, 'CloseDriverNotification', params)

	return ({['NextScreen tabId="' .. HomeTabId .. '"'] = HomeScreenId})
end

function Navigator:LogInCommand (idBinding, seq, args)
	local username = ((args.username ~= '' and args.username) or nil) or self.AuthSettings.username
	local password = ((args.password ~= '' and args.password) or nil)
	if (not password and self.AuthSettings.password) then
		password = C4:Decrypt ('AES-256-CBC', C4:GetDriverConfigInfo ('model'), nil, self.AuthSettings.password, AES_DEC_DEFAULTS)
	end
	if (username and password) then
		Login (username, password, self.navId)
	end
	return ('')
end

function Navigator:LogOutCommand (idBinding, seq, args)
	local params = {
		Id = 'ConfirmLogOut',
		Title = 'Confirm Log Out?',
		Message = 'Are you sure you want to log out?',
	}
	SendEvent (MSP_PROXY, self.navId, nil, 'DriverNotification', params)
	return ('')
end

function Navigator:CancelLogOut (idBinding, seq, args)
	return ({['NextScreen tabId="' .. HomeTabId .. '"'] = HomeScreenId})
end

function Navigator:ConfirmLogOut (idBinding, seq, args)
	for roomId, deviceId in pairs (RoomIDDigitalMedia) do
		if (deviceId == PROXY_ID) then
			C4:SendToDevice (roomId, 'ROOM_OFF', {})
		end
	end

	self.AuthSettings = {}
	PersistData.AuthSettings = {}

	if (Logout) then
		Logout ()
	end

	return ({NextScreen = '#home'})
end

function Navigator:SettingChanged (idBinding, seq, args)
	local value = args.Value
	if (args.PropertyName == 'password') then
		value = C4:Encrypt ('AES-256-CBC', C4:GetDriverConfigInfo ('model'), nil, value, AES_ENC_DEFAULTS)
	end
	self.AuthSettings [args.PropertyName] = value
	return ('')
end

function Navigator:GetSettings (idBinding, seq, args)
	local status
	if (LOGGED_IN == true) then
		status = 'Logged In'
	elseif (LOGGED_IN) then
		status = LOGGED_IN
	else
		status = 'Logged Out'
	end
	local username = self.AuthSettings.username or ''
	local password = ''
	if (self.AuthSettings.password) then
		password = C4:Decrypt ('AES-256-CBC', C4:GetDriverConfigInfo ('model'), nil, self.AuthSettings.password, AES_DEC_DEFAULTS)
	end

	local settings = XMLTag ('username', username) .. XMLTag ('password', password) .. XMLTag ('status', status)
	return {Settings = settings}
end

function Navigator:GetSearchHistory (idBinding, seq, args)
	if (Search) then
		local list = {}
		for _, name in ipairs (Search) do
			table.insert (list, XMLTag ('item', {name = name}))
		end

		list = table.concat (list)
		return ({List = list})
	else
		return ('')
	end
end
 end)
package.preload['drivers-common-public.global.timer'] = (function (...)
-- Copyright 2020 Wirepath Home Systems, LLC. All rights reserved.

COMMON_TIMER_VER = 10

do	--Globals
	Timer = Timer or {}
	TimerFunctions = TimerFunctions or {}

	DEBUG_TIMER = false
end

do -- Define intervals as ms
	ONE_SECOND = 1000
	ONE_MINUTE = 60 * ONE_SECOND
	ONE_HOUR = 60 * ONE_MINUTE
	ONE_DAY = 24 * ONE_HOUR
end

function KillAllTimers ()
	for name, _ in pairs (Timer) do
		CancelTimer (name)
	end

	for _, thisQ in pairs (SongQs or {}) do
		thisQ.ProgressTimer = CancelTimer (thisQ.ProgressTimer)
	end
end

function CancelTimer (timerId)
	local timer
	if (type (timerId) == 'string') then
		timer = Timer [timerId]
	elseif (type (timerId) == 'userdata') then
		timer = timerId
	end

	if (timer) then
		if (DEBUG_TIMER) then
			print ('Timer cancelled: ' .. tostring (timerId))
		end

		if (timer.Cancel) then
			Timer [timerId] = timer:Cancel ()
		else
			Timer [timerId] = nil
		end
		TimerFunctions [timer] = nil
	end
	return nil
end

function SetTimer (timerId, delay, timerFunction, repeating)
	CancelTimer (timerId)

	if (type (timerFunction) ~= 'function') then
		timerFunction = nil
	end

	if (timerFunction == nil) then
		if (type (_G [timerId]) == 'function') then
			timerFunction = function (timer, skips)
				_G [timerId] ()
			end
		else
			timerFunction = function (timer, skips)
			end
		end
	end

	local _timer = function (timer, skips)
		if (TimerFunctions [timer]) then
			local success, ret = pcall (TimerFunctions [timer], timer, skips)
			if (DEBUG_TIMER) then
				if (success == true) then
					print ('Timer completed: ', timerId, ret)
				elseif (success == false) then
					print ('Timer Regular Expire Lua error: ', timerId, ret)
				end
			end
		end
		if (repeating ~= true) then
			CancelTimer (timer)
			if (Timer [timerId] == timer) then
				CancelTimer (timerId)
			end
		end
	end

	if (DEBUG_TIMER) then
		print ('Timer created: ' .. tostring (timerId))
	end

	local timer = C4:SetTimer (delay, _timer, (repeating == true))
	TimerFunctions [timer] = timerFunction

	if (type (timerId) == 'string') then
		if (timerId and timer) then
			Timer [timerId] = timer
		end
	else
		Timer [timer] = timer
	end
	return timer
end

function ChangeTimer (timerId, delay, timerFunction, repeating)
	local timer
	if (type (timerId) == 'string') then
		timer = Timer [timerId]
	elseif (type (timerId) == 'userdata') then
		timer = timerId
	end

	if (TimerFunctions [timer] == nil) then
		return nil
	end

	if (type (timerFunction) ~= 'function') then
		timerFunction = TimerFunctions [timer]
	end

	if (delay == nil) then
		TimerFunctions [timer] = timerFunction
		return timer

	else
		return (SetTimer (timerId, delay, timerFunction, repeating))
	end
end

function ExpireTimer (timerId, keepAlive)
	local timer
	if (type (timerId) == 'string') then
		timer = Timer [timerId]
	elseif (type (timerId) == 'userdata') then
		timer = timerId
	end

	if (TimerFunctions [timer]) then
		local skips = 0
		local success, ret = pcall (TimerFunctions [timer], timer, skips)
		if (success == true) then
			return (ret)
		elseif (success == false) then
			print ('Timer Force Expire Lua error: ', timerId, ret)
		end
	end

	if (keepAlive ~= true) then
		CancelTimer (timerId)
	end
end
 end)
package.preload['drivers-common-public.global.url'] = (function (...)
-- Copyright 2021 Snap One, LLC. All rights reserved.

COMMON_URL_VER = 23

JSON = require ('drivers-common-public.module.json')

require ('drivers-common-public.global.lib')

Metrics = require ('drivers-common-public.module.metrics')


do	--Globals
	GlobalTicketHandlers = GlobalTicketHandlers or {}

	ETag = ETag or {}
	MAX_CACHE = 100

	USE_NEW_URL = VersionCheck ('3.0.0')

	DEBUG_URL = DEBUG_URL or false
end

do	--Setup Metrics
	MetricsURL = Metrics:new ('dcp_url', COMMON_URL_VER)
end

function MakeURL (path, args, suppressDefaultArgs)
	local url = {}
	local args = (type (args) == 'table' and args) or {}

	local schemePart, authorityPart, pathPart, pagePart, queryPart, fragmentPart

	if (DEFAULT_URL_ARGS and type (DEFAULT_URL_ARGS) == 'table' and suppressDefaultArgs ~= true) then
		for k, v in pairs (DEFAULT_URL_ARGS) do
			args [k] = v
		end
	end

	if (APIBase and path and not (string.find ((path or ''), '^http'))) then
		path = APIBase .. path
	end

	if (path) then
		local rest
		schemePart, rest = string.match (path, '(%a+:)(.*)')
		if (not (schemePart == 'http:' or schemePart == 'https:')) then
			return
		end

		authorityPart, path = string.match (rest, '(//.-/)(.*)')

		pathPart, pagePart = string.match (path, '(.*/)(.*)')
		if (pathPart == nil and pagePart == nil) then
			pagePart = path
		end

		local p, q = string.match (pagePart, '(.*)%?(.*)')
		if (p and q) then
			pagePart = p
			queryPart = q
		end

		if (queryPart) then
			local q, f = string.match (queryPart, '(.*)%#(.*)')
			if (q and f) then
				queryPart = q
				fragmentPart = f
			end
		else
			local p, f = string.match (pagePart, '(.*)%#(.*)')
			if (p and f) then
				pagePart = p
				fragmentPart = f
			end
		end

		if (pathPart) then
			local parts = {}
			for part in string.gmatch (pathPart , '([^%/]+)') do
				if (string.match (part, '%.%.$')) then
					table.remove (parts, #parts)
				else
					if (not (string.find (part, '?') or string.find (part, '#'))) then
						table.insert (parts, part)
					end
				end
			end
			table.insert (parts, '')	--ensure trailing slash
			pathPart = table.concat (parts, '/')
		end

		if (queryPart) then
			args = args or {}
			for pair in string.gmatch (queryPart or '', '[^%&]+') do
				local k, v = string.match (pair, '(.+)%=(.+)')
				if (args [k] == nil) then
					args [k] = v
				end
			end
		end
	end

	if (schemePart) then
		table.insert (url, schemePart)
	end
	if (authorityPart) then
		table.insert (url, authorityPart)
	end
	if (pathPart) then
		table.insert (url, pathPart)
	end
	if (pagePart) then
		table.insert (url, pagePart)
	end

	local urlargs = {}
	for k, v in pairs (args) do
		table.insert (urlargs, URLEncode (k) .. '=' .. URLEncode (v))
	end

	if (#urlargs > 0) then
		table.sort (urlargs)
		if (path) then
			table.insert (url, '?')
		end

		urlargs = table.concat (urlargs, '&')
		table.insert (url, urlargs)
	end

	if (fragmentPart) then
		table.insert (url, '#')
		table.insert (url, fragmentPart)
	end

	url = table.concat (url)

	return (url)
end

function URLDecode (s, plusIsSpace)
	if (s == nil) then return '' end
	s = tostring (s)

	if (plusIsSpace == true) then
		s = string.gsub (s, '%+', ' ')
	end

	local _gsub = function (byte)
		local b = tonumber (byte, 16)
		return (string.char (b))
	end

	s = string.gsub (s, '%%(%x%x)', _gsub)

	return s
end

function URLEncode (s, spaceAsPercent)
	if (s == nil) then return '' end
	s = tostring (s)

	local _gsub = function (c)
		return string.format ('%%%02X', string.byte (c))
	end

	s = string.gsub (s, '([^%w%-%.%_%~% ])', _gsub)

	if (spaceAsPercent) then
		s = string.gsub (s, ' ', '%%20')
	else
		s = string.gsub (s, ' ', '+')
	end
	return s
end

function PrintCookies ()
	local cookies = {}

	for url, tab in pairs (C4:urlGetCookies ()) do
		table.insert (cookies, '------------------------')
		table.insert (cookies, url)
		for cookie, data in pairs (tab) do
			table.insert (cookies, '----> ' .. cookie)
			table.insert (cookies, data.value)
		end
		table.insert (cookies, '------------------------')
	end

	print (table.concat (cookies, '\r\n'))
end

function ReceivedAsync (ticketId, strData, responseCode, tHeaders, strError)
	for k, info in pairs (GlobalTicketHandlers) do
		if (info.TICKET == ticketId) then
			MetricsURL:SetCounter ('RX')
			table.remove (GlobalTicketHandlers, k)
			ProcessResponse (strData, responseCode, tHeaders, strError, info)
		end
	end
end

function ProcessResponse (strData, responseCode, tHeaders, strError, info)

	local eTagHit
	local eTagURL

	if (ETag) then
		local tag
		for k, v in pairs (tHeaders) do
			if (string.upper (k) == 'ETAG') then
				tag = v
			end
		end

		local url = info.URL

		for k, v in pairs (ETag) do
			if (v.url == url) then
				eTagURL = k
			end
		end

		if (responseCode == 200 and strError == nil) then
			if (strData == nil) then
				strData = ''
			end

			if (eTagURL) then
				table.remove (ETag, eTagURL)
			end
			if (tag and info.METHOD ~= 'DELETE') then
				table.insert (ETag, 1, {url = url, strData = strData, tHeaders = tHeaders, tag = tag})
			end

		elseif (tag and responseCode == 304 and strError == nil) then
			if (eTagURL) then
				eTagHit = true
				strData = ETag [eTagURL].strData
				tHeaders = ETag [eTagURL].tHeaders
				table.remove (ETag, eTagURL)
				table.insert (ETag, 1, {url = url, strData = strData, tHeaders = tHeaders, tag = tag})
				responseCode = 200
			end
		end

		while (#ETag > MAX_CACHE) do
			table.remove (ETag, #ETag)
		end
	end

	if (DEBUG_URL) then
		local t, ms
		if (C4.GetTime) then
			t = C4:GetTime ()
			ms = '.' .. tostring (t % 1000)
			t = math.floor (t / 1000)
		else
			t = os.time ()
			ms = ''
		end
		local s = os.date ('%x %X') .. ms

		local d = {
			'---',
			'RX ' .. s,
		}

		if (eTagHit) then
			table.insert (d, '---- ETAG CACHE HIT ----')
		end

		table.insert (d, '')
		table.insert (d, info.METHOD .. ' ' .. info.URL .. ' ' .. responseCode)

		if (strError ~= nil) then
			table.insert (d, '---- URL ERROR ----')
			table.insert (d, strError)
			table.insert (d, '-------------------')
		end

		for k, v in pairs (tHeaders) do
			if (k == 'Authorization') then
				table.insert (d, k .. ' = <hidden in print>')
			else
				table.insert (d, k .. ' = ' .. v)
			end
		end
		table.insert (d, '')
		table.insert (d, '-:PAYLOAD:-')
		table.insert (d, strData)
		table.insert (d, '-:PAYLOAD_ENDS:-')
		table.insert (d, '---')
		d = table.concat (d, '\r\n')

		print (d)

		C4:DebugLog (d)
	end

	local data, isJSON, len

	for k, v in pairs (tHeaders) do
		if (string.upper (k) == 'CONTENT-TYPE') then
			if (string.find (v, 'application/json')) then
				isJSON = true
			end
		end
		if (string.upper (k) == 'CONTENT-LENGTH') then
			len = tonumber (v) or 0
		end
	end

	if (isJSON and strError == nil) then
		data = JSON:decode (strData)
		if (data == nil and len ~= 0) then
			print ('Content-Type indicated JSON but content is not valid JSON')

			MetricsURL:SetCounter ('Error_RX_JSON')

			data = {strData}
		end
	else
		data = strData
	end

	if (DEBUG_URL) then
		DATA = data
		CONTEXT = info.CONTEXT
	end

	if (strError) then
		MetricsURL:SetString ('Error_RX', strError)
	end

	if (info.METHOD) then
		MetricsURL:SetCounter ('RX_' .. info.METHOD)
	end

	if (info.CALLBACK and type (info.CALLBACK) == 'function') then
		success, ret = pcall (info.CALLBACK, strError, responseCode, tHeaders, data, info.CONTEXT, info.URL)
	end

	if (success == true) then
		return (ret)
	elseif (success == false) then
		MetricsHandler:SetCounter ('Error_Callback')
		print ('URL response callback error: ', ret, info.URL)
	end
end

function urlDo (method, url, data, headers, callback, context, options)
	local info = {}
	if (type (callback) == 'function') then
		info.CALLBACK = callback
	end

	if (context == nil) then
		context = {}
	end

	method = string.upper (method)

	info.CONTEXT = context
	info.URL = url
	info.METHOD = method

	headers = CopyTable (headers) or {}

	data = data or ''

	if (headers ['User-Agent'] == nil) then
		headers ['User-Agent'] = USER_AGENT
	end

	if (type (data) == 'table') then
		data = JSON:encode (data)
		headers ['Content-Type'] = 'application/json'
	end

	for _, etag in pairs (ETag or {}) do
		if (etag.url == url) then
			headers ['If-None-Match'] = etag.tag
		end
	end

	if (DEBUG_URL) then
		local t, ms
		if (C4.GetTime) then
			t = C4:GetTime ()
			ms = '.' .. tostring (t % 1000)
			t = math.floor (t / 1000)
		else
			t = os.time ()
			ms = ''
		end
		local s = os.date ('%x %X') .. ms


		local d = {
			'---',
			'TX ' .. s,
		}

		table.insert (d, '')
		table.insert (d, method .. ' ' .. url)
		for k, v in pairs (headers) do
			if (k == 'Authorization') then
				table.insert (d, k .. ' = <hidden in print>')
			else
				table.insert (d, k .. ' = ' .. v)
			end
		end
		table.insert (d, '')
		table.insert (d, '-:PAYLOAD:-')
		table.insert (d, data)
		table.insert (d, '-:PAYLOAD_ENDS:-')
		table.insert (d, '---')

		d = table.concat (d, '\r\n')

		print (d)

		C4:DebugLog (d)
	end

	if (USE_NEW_URL) then
		local t = C4:url ()

		local startTime
		if (C4.GetTime) then
			startTime = C4:GetTime ()
		else
			startTime = os.time () * 1000
		end

		options = CopyTable (options) or {}

		if (options ['cookies_enable'] == nil) then
			options ['cookies_enable'] = true
		end

		if (options ['fail_on_error'] == nil) then
			options ['fail_on_error'] = false
		end

		t:SetOptions (options)

		local _onDone = function (transfer, responses, errCode, errMsg)
			MetricsURL:SetCounter ('RX')

			local endTime
			if (C4.GetTime) then
				endTime = C4:GetTime ()
			else
				endTime = os.time () * 1000
			end
			local interval = endTime - startTime
			MetricsURL:SetTimer ('TXtoRX', interval)

			if (errCode == -1 and errMsg == nil) then
				errMsg = 'Transfer cancelled'
			end

			local strError = errMsg

			local strData, responseCode, tHeaders = '', 0, {}

			if (errCode == 0) then
				strData = responses [#responses].body
				responseCode = responses [#responses].code
				tHeaders = responses [#responses].headers
			end

			ProcessResponse (strData, responseCode, tHeaders, strError, info)

			local processTime
			if (C4.GetTime) then
				processTime = C4:GetTime ()
			else
				processTime = os.time () * 1000
			end
			local interval = processTime - startTime
			MetricsURL:SetTimer ('TXtoDone', interval)
		end

		t:OnDone (_onDone)

		MetricsURL:SetCounter ('TX')

		if (method == 'GET') then
			t:Get (url, headers)
		elseif (method == 'POST') then
			t:Post (url, data, headers)
		elseif (method == 'PUT') then
			t:Put (url, data, headers)
		elseif (method == 'DELETE') then
			t:Delete (url, headers)
		else
			t:Custom (url, method, data, headers)
		end

		return t
	else
		local flags = CopyTable (options)

		if (flags == nil) then
			flags = {
				--response_headers_merge_redirects = false,
				cookies_enable = true
			}
		end

		MetricsURL:SetCounter ('TX')

		if (method == 'GET') then
			info.TICKET = C4:urlGet (url, headers, false, ReceivedAsync, flags)
		elseif (method == 'POST') then
			info.TICKET = C4:urlPost (url, data, headers, false, ReceivedAsync, flags)
		elseif (method == 'PUT') then
			info.TICKET = C4:urlPut (url, data, headers, false, ReceivedAsync, flags)
		elseif (method == 'DELETE') then
			info.TICKET = C4:urlDelete (url, headers, false, ReceivedAsync, flags)
		else
			info.TICKET = C4:urlCustom (url, method, data, headers, false, ReceivedAsync, flags)
		end

		if (info.TICKET and info.TICKET ~= 0) then
			table.insert (GlobalTicketHandlers, info)

		else
			MetricsURL:SetCounter ('Error_TX')

			dbg ('C4.Curl error: ' .. info.METHOD .. ' ' .. url)
			if (callback) then
				pcall (callback, 'No ticket', nil, nil, '', context, url)
			end
		end

		return info
	end
end

function urlGet (url, headers, callback, context, options)
	MetricsURL:SetCounter ('TX_GET')
	urlDo ('GET', url, data, headers, callback, context, options)
end

function urlPost (url, data, headers, callback, context, options)
	MetricsURL:SetCounter ('TX_POST')
	urlDo ('POST', url, data, headers, callback, context, options)
end

function urlPut (url, data, headers, callback, context, options)
	MetricsURL:SetCounter ('TX_PUT')
	urlDo ('PUT', url, data, headers, callback, context, options)
end

function urlDelete (url, headers, callback, context, options)
	MetricsURL:SetCounter ('TX_DELETE')
	urlDo ('DELETE', url, data, headers, callback, context, options)
end

function urlCustom (url, method, data, headers, callback, context, options)
	MetricsURL:SetCounter ('TX_' .. method)
	urlDo (method, url, data, headers, callback, context, options)
end
 end)
package.preload['drivers-common-public.module.auth_code_grant'] = (function (...)
-- Copyright 2022 Snap One, LLC. All rights reserved.

AUTH_CODE_GRANT_VER = 24

require ('drivers-common-public.global.lib')
require ('drivers-common-public.global.url')
require ('drivers-common-public.global.timer')

pcall (require, 'drivers-common-public.global.make_short_link')

Metrics = require ('drivers-common-public.module.metrics')

local oauth = {}

function oauth:new (tParams, providedRefreshToken)
	local o = {
		NAME = tParams.NAME,
		AUTHORIZATION = tParams.AUTHORIZATION,

		SHORT_LINK_AUTHORIZATION = tParams.SHORT_LINK_AUTHORIZATION,
		LINK_CHANGE_CALLBACK = tParams.LINK_CHANGE_CALLBACK,

		REDIRECT_URI = tParams.REDIRECT_URI,
		AUTH_ENDPOINT_URI = tParams.AUTH_ENDPOINT_URI,
		TOKEN_ENDPOINT_URI = tParams.TOKEN_ENDPOINT_URI,

		REDIRECT_DURATION = tParams.REDIRECT_DURATION,

		API_CLIENT_ID = tParams.API_CLIENT_ID,
		API_SECRET = tParams.API_SECRET,

		SCOPES = tParams.SCOPES,

		TOKEN_HEADERS = tParams.TOKEN_HEADERS,

		notifyHandler = {},
		Timer = {},
	}

	if (tParams.USE_BASIC_AUTH_HEADER) then
		o.BasicAuthHeader = 'Basic ' .. C4:Base64Encode (tParams.API_CLIENT_ID .. ':' .. tParams.API_SECRET)
	end

	setmetatable (o, self)
	self.__index = self

	o.metrics = Metrics:new ('dcp_auth_code', AUTH_CODE_GRANT_VER, (o.NAME or o.API_CLIENT_ID))

	local initialRefreshToken

	if (providedRefreshToken) then
		initialRefreshToken = providedRefreshToken
	else
		local persistStoreKey = C4:Hash ('SHA256', C4:GetDeviceID () .. o.API_CLIENT_ID, SHA_ENC_DEFAULTS)
		local encryptedToken = PersistGetValue (persistStoreKey)
		if (encryptedToken) then
			local encryptionKey = C4:GetDeviceID () .. o.API_SECRET .. o.API_CLIENT_ID
			local refreshToken, errString = SaltedDecrypt (encryptionKey, encryptedToken)
			if (errString) then
				o.metrics:SetString ('Error_DecryptRefreshToken', errString)
			end
				if (refreshToken) then
				initialRefreshToken = refreshToken
			end
		end
	end

	if (initialRefreshToken) then
		o.metrics:SetCounter ('InitWithToken')
		local _timer = function (timer)
			o:RefreshToken (nil, initialRefreshToken)
		end
		SetTimer (nil, ONE_SECOND, _timer)
	else
		o.metrics:SetCounter ('InitWithoutToken')
	end

	local willGenerateRefreshEvent = (initialRefreshToken ~= nil)

	return o, willGenerateRefreshEvent
end

function oauth:MakeState (contextInfo, extras, uriToCompletePage)
	if (type (contextInfo) ~= 'table') then
		contextInfo = {}
	end

	local state = GetRandomString (50)

	local url = MakeURL (self.REDIRECT_URI .. 'state')

	local headers = {
		Authorization = self.AUTHORIZATION,
	}

	local data = {
		duration = self.REDIRECT_DURATION,
		clientId = self.API_CLIENT_ID,
		authEndpointURI = self.AUTH_ENDPOINT_URI,
		state = state,
		redirectURI = uriToCompletePage,
	}

	local context = {
		contextInfo = contextInfo,
		state = state,
		extras = extras
	}

	self.metrics:SetCounter ('MakeStateAttempt')
	self:urlPost (url, data, headers, 'MakeStateResponse', context)
end

function oauth:MakeStateResponse (strError, responseCode, tHeaders, data, context, url)
	if (strError) then
		dbg ('Error with MakeState', strError)
		return
	end

	local contextInfo = context.contextInfo

	if (responseCode == 200) then
		self.metrics:SetCounter ('MakeStateSuccess')
		local state = context.state
		local extras = context.extras

		local nonce = data.nonce
		local expiresAt = data.expiresAt or (os.time () + self.REDIRECT_DURATION)

		local timeRemaining = expiresAt - os.time ()

		local _timedOut = function (timer)
			CancelTimer (self.Timer.CheckState)

			self:setLink ('')

			self.metrics:SetCounter ('ActivationTimeOut')
			self:notify ('ActivationTimeOut', contextInfo)
		end

		self.Timer.GetCodeStatusExpired = SetTimer (self.Timer.GetCodeStatusExpired, timeRemaining * ONE_SECOND, _timedOut)

		local _timer = function (timer)
			self:CheckState (state, contextInfo, nonce)
		end
		self.Timer.CheckState = SetTimer (self.Timer.CheckState, 5 * ONE_SECOND, _timer, true)

		self:GetLinkCode (state, contextInfo, extras)
	end
end

function oauth:GetLinkCode (state, contextInfo, extras)
	if (type (contextInfo) ~= 'table') then
		contextInfo = {}
	end

	local scope
	if (self.SCOPES) then
		if (type (self.SCOPES) == 'table') then
			scope = table.concat (self.SCOPES, ' ')
		elseif (type (self.SCOPES) == 'string') then
			scope = self.SCOPES
		end
	end

	local args = {
		client_id = self.API_CLIENT_ID,
		response_type = 'code',
		redirect_uri = self.REDIRECT_URI .. 'callback',
		state = state,
		scope = scope,
	}

	if (extras and type (extras) == 'table') then
		for k, v in pairs (extras) do
			args [k] = v
		end
	end

	local link = MakeURL (self.AUTH_ENDPOINT_URI, args)

	if (self.SHORT_LINK_AUTHORIZATION and MakeShortLink) then
		local _linkCallback = function (shortLink)
			self:setLink (shortLink, contextInfo)
		end
		MakeShortLink (link, _linkCallback, self.SHORT_LINK_AUTHORIZATION)
	else
		self:setLink (link, contextInfo)
	end
end

function oauth:CheckState (state, contextInfo, nonce)
	if (type (contextInfo) ~= 'table') then
		contextInfo = {}
	end

	local url = MakeURL (self.REDIRECT_URI .. 'state', {state = state, nonce = nonce})

	self:urlGet (url, nil, 'CheckStateResponse', {state = state, contextInfo = contextInfo})
end

function oauth:CheckStateResponse (strError, responseCode, tHeaders, data, context, url)
	if (strError) then
		dbg ('Error with CheckState:', strError)
		return
	end

	local contextInfo = context.contextInfo

	if (responseCode == 200 and data.code) then
		-- state exists and has been authorized

		CancelTimer (self.Timer.CheckState)
		CancelTimer (self.Timer.GetCodeStatusExpired)

		self:GetUserToken (data.code, contextInfo)

		self.metrics:SetCounter ('LinkCodeConfirmed')
		self:notify ('LinkCodeConfirmed', contextInfo)

	elseif (responseCode == 204) then
		self:notify ('LinkCodeWaiting', contextInfo)

	elseif (responseCode == 401) then
		-- nonce value incorrect or missing for this state

		CancelTimer (self.Timer.CheckState)
		CancelTimer (self.Timer.GetCodeStatusExpired)

		self:setLink ('')

		self.metrics:SetCounter ('LinkCodeError')
		self:notify ('LinkCodeError', contextInfo)

	elseif (responseCode == 403) then
		-- state exists and has been denied authorization by the service

		CancelTimer (self.Timer.CheckState)
		CancelTimer (self.Timer.GetCodeStatusExpired)

		self:setLink ('')

		self.metrics:SetCounter ('LinkCodeDenied')
		if (data.error) then
			self.metrics:SetString ('LinkCodeDeniedReason', data.error)
		end
		if (data.error_description) then
			self.metrics:SetString ('LinkCodeDeniedDescription', data.error_description)
		end
		self:notify ('LinkCodeDenied', contextInfo, data.error, data.error_description, data.error_uri)

	elseif (responseCode == 404) then
		-- state doesn't exist

		CancelTimer (self.Timer.CheckState)
		CancelTimer (self.Timer.GetCodeStatusExpired)

		self:setLink ('')

		self.metrics:SetCounter ('LinkCodeExpired')
		self:notify ('LinkCodeExpired', contextInfo)
	end
end

function oauth:GetUserToken (code, contextInfo)
	if (type (contextInfo) ~= 'table') then
		contextInfo = {}
	end

	if (code) then
		local args = {
			client_id = self.API_CLIENT_ID,
			client_secret = self.API_SECRET,
			grant_type = 'authorization_code',
			code = code,
			redirect_uri = self.REDIRECT_URI .. 'callback',
		}

		local url = self.TOKEN_ENDPOINT_URI

		local data = MakeURL (nil, args)

		local headers = {
			['Content-Type'] = 'application/x-www-form-urlencoded',
			['Authorization'] = self.BasicAuthHeader,
		}

		if (self.TOKEN_HEADERS and type (self.TOKEN_HEADERS == 'table')) then
			for k, v in pairs (self.TOKEN_HEADERS) do
				if (not (headers [k])) then
					headers [k] = v
				end
			end
		end

		self:urlPost (url, data, headers, 'GetTokenResponse', {contextInfo = contextInfo})
	end
end

function oauth:RefreshToken (contextInfo, newRefreshToken)
	if (newRefreshToken) then
		self.REFRESH_TOKEN = newRefreshToken
	end

	if (self.REFRESH_TOKEN == nil) then
		self.metrics:SetCounter ('NoRefreshToken')
		return false
	end

	if (type (contextInfo) ~= 'table') then
		contextInfo = {}
	end

	local args = {
		refresh_token = self.REFRESH_TOKEN,
		client_id = self.API_CLIENT_ID,
		client_secret = self.API_SECRET,
		grant_type = 'refresh_token',
	}

	local url = self.TOKEN_ENDPOINT_URI

	local data = MakeURL (nil, args)

	local headers = {
		['Content-Type'] = 'application/x-www-form-urlencoded',
		['Authorization'] = self.BasicAuthHeader,
	}

	if (self.TOKEN_HEADERS and type (self.TOKEN_HEADERS == 'table')) then
		for k, v in pairs (self.TOKEN_HEADERS) do
			if (not (headers [k])) then
				headers [k] = v
			end
		end
	end

	self:urlPost (url, data, headers, 'GetTokenResponse', {contextInfo = contextInfo})
end

function oauth:GetTokenResponse (strError, responseCode, tHeaders, data, context, url)
	if (strError) then
		dbg ('Error with GetToken:', strError)
		local _timer = function (timer)
			self:RefreshToken ()
		end
		self.Timer.RefreshToken = SetTimer (self.Timer.RefreshToken, 30 * 1000, _timer)
		return
	end

	local contextInfo = context.contextInfo

	if (responseCode == 200) then
		self.ACCESS_TOKEN = data.access_token
		self.REFRESH_TOKEN = data.refresh_token or self.REFRESH_TOKEN

		local persistStoreKey = C4:Hash ('SHA256', C4:GetDeviceID () .. self.API_CLIENT_ID, SHA_ENC_DEFAULTS)

		local encryptionKey = C4:GetDeviceID () .. self.API_SECRET .. self.API_CLIENT_ID
		local encryptedToken, errString = SaltedEncrypt (encryptionKey, self.REFRESH_TOKEN)
		if (errString) then
			self.metrics:SetString ('Error_EncryptRefreshToken', errString)
		end

		PersistSetValue (persistStoreKey, encryptedToken)

		self.SCOPE = data.scope or self.SCOPE

		self.EXPIRES_IN = data.expires_in

		if (self.EXPIRES_IN and self.REFRESH_TOKEN) then
			local _timer = function (timer)
				self:RefreshToken ()
			end

			self.Timer.RefreshToken = SetTimer (self.Timer.RefreshToken, self.EXPIRES_IN * 950, _timer)
		end

		print ((self.NAME or 'OAuth') .. ': Access Token received, accessToken:' .. tostring (self.ACCESS_TOKEN ~= nil) .. ', refreshToken:' .. tostring (self.REFRESH_TOKEN ~= nil))

		self:setLink ('')

		self.metrics:SetCounter ('AccessTokenGranted')
		self:notify ('AccessTokenGranted', contextInfo, self.ACCESS_TOKEN, self.REFRESH_TOKEN)

	elseif (responseCode >= 400 and responseCode < 500) then
		self.ACCESS_TOKEN = nil
		self.REFRESH_TOKEN = nil

		local persistStoreKey = C4:Hash ('SHA256', C4:GetDeviceID () .. self.API_CLIENT_ID, SHA_ENC_DEFAULTS)

		PersistDeleteValue (persistStoreKey)

		print ((self.NAME or 'OAuth') .. ': Access Token denied:', data.error, data.error_description, data.error_uri)

		self:setLink ('')


		self.metrics:SetCounter ('AccessTokenDenied')
		if (data.error) then
			self.metrics:SetString ('AccessTokenDeniedReason', data.error)
		end
		if (data.error_description) then
			self.metrics:SetString ('AccessTokenDeniedDescription', data.error_description)
		end
		self:notify ('AccessTokenDenied', contextInfo, data.error, data.error_description, data.error_uri)
	end
end

function oauth:DeleteRefreshToken ()
	local persistStoreKey = C4:Hash ('SHA256', C4:GetDeviceID () .. self.API_CLIENT_ID, SHA_ENC_DEFAULTS)
	PersistDeleteValue (persistStoreKey)
	self.ACCESS_TOKEN = nil
	self.REFRESH_TOKEN = nil

	self.Timer.RefreshToken = CancelTimer (self.Timer.RefreshToken)

	self.metrics:SetCounter ('RefreshTokenDeleted')
end

function oauth:setLink (link, contextInfo)
	if (link ~= '') then
		self.metrics:SetCounter ('LinkCodeReceived')
	end
	self:notify ('LinkCodeReceived', contextInfo, link)

	if (self.LINK_CHANGE_CALLBACK and type (self.LINK_CHANGE_CALLBACK) == 'function') then
		local success, ret = pcall (self.LINK_CHANGE_CALLBACK, link, contextInfo)
		if (success == false) then
			print ((self.NAME or 'OAuth') .. ':LINK_CHANGE_CALLBACK Lua error: ', link, ret)
		end
	end
end

function oauth:notify (handler, ...)
	if (self.notifyHandler [handler] and type (self.notifyHandler [handler]) == 'function') then
		local success, ret = pcall (self.notifyHandler [handler], ...)
		if (success == false) then
			print ((self.NAME or 'OAuth') .. ':' .. handler .. ' Lua error: ', ret, ...)
		end
	end
end

function oauth:urlDo (method, url, data, headers, callback, context)
	local ticketHandler = function (strError, responseCode, tHeaders, data, context, url)
		local func = self [callback]
		local success, ret = pcall (func, self, strError, responseCode, tHeaders, data, context, url)
	end

	urlDo (method, url, data, headers, ticketHandler, context)
end

function oauth:urlGet (url, headers, callback, context)
	self:urlDo ('GET', url, data, headers, callback, context)
end

function oauth:urlPost (url, data, headers, callback, context)
	self:urlDo ('POST', url, data, headers, callback, context)
end

function oauth:urlPut (url, data, headers, callback, context)
	self:urlDo ('PUT', url, data, headers, callback, context)
end

function oauth:urlDelete (url, headers, callback, context)
	self:urlDo ('DELETE', url, data, headers, callback, context)
end

function oauth:urlCustom (url, method, data, headers, callback, context)
	self:urlDo (method, url, data, headers, callback, context)
end

return oauth
 end)
package.preload['drivers-common-public.module.auth_device_PIN'] = (function (...)
-- Copyright 2019 Control4 Corporation. All rights reserved.

AUTH_DEVICE_PIN_VER = 6

require ('drivers-common-public.global.url')
require ('drivers-common-public.global.timer')

local oauth = {}

function oauth:new (tParams)
	local o = {
		AUTH_ENDPOINT_URI = tParams.AUTH_ENDPOINT_URI,
		TOKEN_ENDPOINT_URI = tParams.TOKEN_ENDPOINT_URI,

		API_CLIENT_ID = tParams.API_CLIENT_ID,
		API_SECRET = tParams.API_SECRET,

		SCOPES = tParams.SCOPES,

		notifyHandler = {},
		Timer = {},
	}

	setmetatable (o, self)
	self.__index = self

	return o
end

function oauth:GetPINCode (contextInfo, extras)
	--print ('GetPINCode', contextInfo)
	if (type (contextInfo) ~= 'table') then
		contextInfo = {}
	end

	local args = {
		client_id = self.API_CLIENT_ID,
		scope = (self.SCOPES and table.concat (self.SCOPES, ' ')) or nil,
	}

	if (extras and type (extras == 'table')) then
		for k, v in pairs (extras) do
			args [k] = v
		end
	end

	local url = self.AUTH_ENDPOINT_URI

	local data = MakeURL (nil, args)

	local headers = {
		['Content-Type'] = 'application/x-www-form-urlencoded'
	}

	self:urlPost (url, data, headers, 'GetPINCodeResponse', {contextInfo = contextInfo})
end

function oauth:GetPINCodeResponse (strError, responseCode, tHeaders, data, context, url)
	--print ('GetPINCodeResponse', strError, responseCode, tHeaders, data, context, url)
	if (strError) then
		dbg ('Error with GetPINCodeResponse:', strError)
		return
	end

	local contextInfo = context.contextInfo

	if (responseCode == 200) then
		self.device_code = data.device_code
		local user_code = data.user_code
		local verification_url = data.verification_url
		local expires_in = data.expires_in or (5 * ONE_MINUTE)
		local interval = data.interval or 5

		if (self.notifyHandler.PINCodeReceived) then
			self.notifyHandler.PINCodeReceived (contextInfo, verification_url, user_code)
		end

		local _timedOut = function (timer)
			CancelTimer (self.Timer.CheckPINCode)

			if (self.notifyHandler.PINCodeExpired) then
				self.notifyHandler.PINCodeExpired (contextInfo)
			end
		end
		self.Timer.GetPINCodeExpired = SetTimer (self.Timer.GetPINCodeExpired, expires_in * 1000, _timedOut)

		local _timer = function (timer)
			self:CheckPINCode (contextInfo)
		end
		self.Timer.CheckPINCode = SetTimer (self.Timer.CheckPINCode, interval * 1000, _timer, true)
	end
end

function oauth:CheckPINCode (contextInfo)
	--print ('CheckPINCode', contextInfo)

	if (type (contextInfo) ~= 'table') then
		contextInfo = {}
	end

	local args = {
		client_id = self.API_CLIENT_ID,
		client_secret = self.API_SECRET,
		code = self.device_code,
		grant_type = 'http://oauth.net/grant_type/device/1.0',
	}

	local url = self.TOKEN_ENDPOINT_URI

	local data = MakeURL (nil, args)

	local headers = {
		['Content-Type'] = 'application/x-www-form-urlencoded'
	}

	self:urlPost (url, data, headers, 'CheckPINCodeResponse', {contextInfo = contextInfo})
end

function oauth:CheckPINCodeResponse (strError, responseCode, tHeaders, data, context, url)
	--print ('CheckPINCodeResponse', strError, responseCode, tHeaders, data, context, url)
	if (strError) then
		dbg ('Error with CheckPINCodeResponse:', strError)
		return
	end

	local contextInfo = context.contextInfo

	if (responseCode == 200) then
		-- state exists and has been authorized
		CancelTimer (self.Timer.CheckPINCode)
		CancelTimer (self.Timer.GetPINCodeExpired)

		self:GetTokenResponse (strError, responseCode, tHeaders, data, context, url)

	elseif (responseCode == 400) then
		if (self.notifyHandler.PINCodeWaiting) then
			self.notifyHandler.PINCodeWaiting (contextInfo)
		end

	elseif (responseCode == 403) then
		-- state exists and has been denied authorization by the service

		if (self.notifyHandler.PINCodeDenied) then
			self.notifyHandler.PINCodeDenied (contextInfo, data.error, data.error_description, data.error_uri)
		end

		CancelTimer (self.Timer.CheckPINCode)
		CancelTimer (self.Timer.GetPINCodeExpired)
	end
end

function oauth:RefreshToken (contextInfo)
	--print ('RefreshToken')
	if (self.REFRESH_TOKEN == nil) then
		return
	end

	if (type (contextInfo) ~= 'table') then
		contextInfo = {}
	end

	local args = {
		refresh_token = self.REFRESH_TOKEN,
		client_id = self.API_CLIENT_ID,
		client_secret = self.API_SECRET,
		grant_type = 'refresh_token',
	}

	local url = self.TOKEN_ENDPOINT_URI

	local data = MakeURL (nil, args)

	local headers = {
		['Content-Type'] = 'application/x-www-form-urlencoded',
	}

	self:urlPost (url, data, headers, 'GetTokenResponse', {contextInfo = contextInfo})
end

function oauth:GetTokenResponse (strError, responseCode, tHeaders, data, context, url)
	--print ('GetTokenResponse', strError, responseCode, tHeaders, data, context, url)
	if (strError) then
		dbg ('Error with GetToken:', strError)
		local _timer = function (timer)
			self:RefreshToken ()
		end
		self.Timer.RefreshToken = SetTimer (self.Timer.RefreshToken, 30 * 1000, _timer)
		return
	end

	local contextInfo = context.contextInfo

	if (responseCode == 200) then
		self.ACCESS_TOKEN = data.access_token
		self.REFRESH_TOKEN = data.refresh_token or self.REFRESH_TOKEN

		self.SCOPE = data.scope or self.SCOPE

		self.EXPIRES_IN = data.expires_in

		if (self.EXPIRES_IN and self.REFRESH_TOKEN) then
			local _timer = function (timer)
				self:RefreshToken ()
			end

			self.Timer.RefreshToken = SetTimer (self.Timer.RefreshToken, self.EXPIRES_IN * 950, _timer)
		end

		if (self.notifyHandler.AccessTokenGranted) then
			self.notifyHandler.AccessTokenGranted (contextInfo, self.ACCESS_TOKEN, self.REFRESH_TOKEN)
		end

	elseif (responseCode >= 400 and responseCode < 500) then
		if (self.notifyHandler.AccessTokenDenied) then
			self.notifyHandler.AccessTokenDenied (contextInfo, data.error, data.error_description, data.error_uri)
		end
	end
end

function oauth:urlDo (method, url, data, headers, callback, context)
	local ticketHandler = function (strError, responseCode, tHeaders, data, context, url)
		local func = self [callback]
		local success, ret = pcall (func, self, strError, responseCode, tHeaders, data, context, url)
	end

	urlDo (method, url, data, headers, ticketHandler, context)
end

function oauth:urlGet (url, headers, callback, context)
	self:urlDo ('GET', url, data, headers, callback, context)
end

function oauth:urlPost (url, data, headers, callback, context)
	self:urlDo ('POST', url, data, headers, callback, context)
end

function oauth:urlPut (url, data, headers, callback, context)
	self:urlDo ('PUT', url, data, headers, callback, context)
end

function oauth:urlDelete (url, headers, callback, context)
	self:urlDo ('DELETE', url, data, headers, callback, context)
end

function oauth:urlCustom (url, method, data, headers, callback, context)
	self:urlDo (method, url, data, headers, callback, context)
end

return oauth
 end)
package.preload['drivers-common-public.module.json'] = (function (...)
--------------------------------------------------------------------------------------------------------
-- JSON parser
--------------------------------------------------------------------------------------------------------
--
-- Copyright 2010-2011 Jeffrey Friedl
-- http://regex.info/blog/
--
local COPYRIGHT = '2010-2011 Jeffrey Friedl'
local URL = 'http://regex.info/blog/'
local VERSION = 20111207.5 -- version history at end of file
OBJDEF = {VERSION = VERSION, URL = URL, COPYRIGHT = COPYRIGHT}

--
-- Simple JSON encoding and decoding in pure Lua.
-- http://www.json.org/
--
--
--   JSON = loadfile "JSON.lua" -- one-time load of the routines
--
--   local lua_value = JSON:decode(raw_json_text)
--
--   local raw_json_text    = JSON:encode(lua_table_or_value)
--   local pretty_json_text = JSON:encode_pretty(lua_table_or_value) -- "pretty printed" version for human readability
--
--
-- DECODING
--
--   JSON = (loadfile "JSON.lua")() -- one-time load of the routines
--
--   local lua_value = JSON:decode(raw_json_text)
--
--   If the JSON text is for an object or an array, e.g.
--     { "what": "books", "count": 3 }
--   or
--     [ "Larry", "Curly", "Moe" ]
--
--   the result is a Lua table, e.g.
--     { what = "books", count = 3 }
--   or
--     { "Larry", "Curly", "Moe" }
--
--
--   The encode and decode routines accept an optional second argument, "etc", which is not used
--   during encoding or decoding, but upon error is passed along to error handlers. It can be of any
--   type (including nil).
--
--   With most errors during decoding, this code calls
--
--      JSON:onDecodeError(message, text, location, etc)
--
--   with a message about the error, and if known, the JSON text being parsed and the byte count
--   where the problem was discovered. You can replace the default JSON:onDecodeError() with your
--   own function.
--
--   The default onDecodeError() merely augments the message with data about the text and the
--   location if known (and if a second 'etc' argument had been provided to decode(), its value is
--   tacked onto the message as well), and then calls JSON.assert(), which itself defaults to Lua's
--   built-in assert(), and can also be overridden.
--
--   For example, in an Adobe Lightroom plugin, you might use something like
--
--          function JSON:onDecodeError(message, text, location, etc)
--             LrErrors.throwUserError("Internal Error: invalid JSON data")
--          end
--
--   or even just
--
--          function JSON.assert(message)
--             LrErrors.throwUserError("Internal Error: " .. message)
--          end
--
--   If JSON:decode() is passed a nil, this is called instead:
--
--      JSON:onDecodeOfNilError(message, nil, nil, etc)
--
--   and if JSON:decode() is passed HTML instead of JSON, this is called:
--
--      JSON:onDecodeOfHTMLError(message, text, nil, etc)
--
--   The use of the fourth 'etc' argument allows stronger coordination between decoding and error
--   reporting, especially when you provide your own error-handling routines. Continuing with the
--   the Adobe Lightroom plugin example:
--
--          function JSON:onDecodeError(message, text, location, etc)
--             local note = "Internal Error: invalid JSON data"
--             if type(etc) = 'table' and etc.photo then
--                note = note .. " while processing for " .. etc.photo:getFormattedMetadata('fileName')
--             end
--             LrErrors.throwUserError(note)
--          end
--
--            :
--            :
--
--          for i, photo in ipairs(photosToProcess) do
--               :
--               :
--               local data = JSON:decode(someJsonText, { photo = photo })
--               :
--               :
--          end
--
--
--
--

-- DECODING AND STRICT TYPES
--
--   Because both JSON objects and JSON arrays are converted to Lua tables, it's not normally
--   possible to tell which a Lua table came from, or guarantee decode-encode round-trip
--   equivalency.
--
--   However, if you enable strictTypes, e.g.
--
--      JSON = (loadfile "JSON.lua")() --load the routines
--      JSON.strictTypes = true
--
--   then the Lua table resulting from the decoding of a JSON object or JSON array is marked via Lua
--   metatable, so that when re-encoded with JSON:encode() it ends up as the appropriate JSON type.
--
--   (This is not the default because other routines may not work well with tables that have a
--   metatable set, for example, Lightroom API calls.)
--
--
-- ENCODING
--
--   JSON = (loadfile "JSON.lua")() -- one-time load of the routines
--
--   local raw_json_text    = JSON:encode(lua_table_or_value)
--   local pretty_json_text = JSON:encode_pretty(lua_table_or_value) -- "pretty printed" version for human readability

--   On error during encoding, this code calls:
--
--    JSON:onEncodeError(message, etc)
--
--   which you can override in your local JSON object.
--
--
-- SUMMARY OF METHODS YOU CAN OVERRIDE IN YOUR LOCAL LUA JSON OBJECT
--
--    assert
--    onDecodeError
--    onDecodeOfNilError
--    onDecodeOfHTMLError
--    onEncodeError
--
--  If you want to create a separate Lua JSON object with its own error handlers,
--  you can reload JSON.lua or use the :new() method.
--
---------------------------------------------------------------------------

local author =
	'-[ JSON.lua package by Jeffrey Friedl (http://regex.info/blog/lua/json), version ' .. tostring(VERSION) .. ' ]-'
local isArray = {__tostring = function()
		return 'JSON array'
	end}
isArray.__index = isArray
local isObject = {__tostring = function()
		return 'JSON object'
	end}
isObject.__index = isObject

function OBJDEF:newArray(tbl)
	return setmetatable(tbl or {}, isArray)
end

function OBJDEF:newObject(tbl)
	return setmetatable(tbl or {}, isObject)
end

local function unicode_codepoint_as_utf8(codepoint)
	--
	-- codepoint is a number
	--
	if codepoint <= 127 then
		return string.char(codepoint)
	elseif codepoint <= 2047 then
		--
		-- 110yyyxx 10xxxxxx         <-- useful notation from http://en.wikipedia.org/wiki/Utf8
		--
		local highpart = math.floor(codepoint / 0x40)
		local lowpart = codepoint - (0x40 * highpart)
		return string.char(0xC0 + highpart, 0x80 + lowpart)
	elseif codepoint <= 65535 then
		--
		-- 1110yyyy 10yyyyxx 10xxxxxx
		--
		local highpart = math.floor(codepoint / 0x1000)
		local remainder = codepoint - 0x1000 * highpart
		local midpart = math.floor(remainder / 0x40)
		local lowpart = remainder - 0x40 * midpart

		highpart = 0xE0 + highpart
		midpart = 0x80 + midpart
		lowpart = 0x80 + lowpart

		--
		-- Check for an invalid character (thanks Andy R. at Adobe).
		-- See table 3.7, page 93, in http://www.unicode.org/versions/Unicode5.2.0/ch03.pdf#G28070
		--
		if
			(highpart == 0xE0 and midpart < 0xA0) or (highpart == 0xED and midpart > 0x9F) or
				(highpart == 0xF0 and midpart < 0x90) or
				(highpart == 0xF4 and midpart > 0x8F)
		then
			return '?'
		else
			return string.char(highpart, midpart, lowpart)
		end
	else
		--
		-- 11110zzz 10zzyyyy 10yyyyxx 10xxxxxx
		--
		local highpart = math.floor(codepoint / 0x40000)
		local remainder = codepoint - 0x40000 * highpart
		local midA = math.floor(remainder / 0x1000)
		remainder = remainder - 0x1000 * midA
		local midB = math.floor(remainder / 0x40)
		local lowpart = remainder - 0x40 * midB

		return string.char(0xF0 + highpart, 0x80 + midA, 0x80 + midB, 0x80 + lowpart)
	end
end

function OBJDEF:onDecodeError(message, text, location, etc)
	if text then
		if location then
			message = string.format('%s at char %d of: %s', message, location, text)
		else
			message = string.format('%s: %s', message, text)
		end
	end
	if etc ~= nil then
		message = message .. ' (' .. OBJDEF:encode(etc) .. ')'
	end

	print ('JSON decode error:' .. message)
end

OBJDEF.onDecodeOfNilError = OBJDEF.onDecodeError
OBJDEF.onDecodeOfHTMLError = OBJDEF.onDecodeError

function OBJDEF:onEncodeError(message, etc)
	if etc ~= nil then
		message = message .. ' (' .. OBJDEF:encode(etc) .. ')'
	end

	print ('JSON encode error:' .. message)
end

local function grok_number(self, text, start, etc)
	--
	-- Grab the integer part
	--
	local integer_part = text:match('^-?[1-9]%d*', start) or text:match('^-?0', start)

	if not integer_part then
		self:onDecodeError('expected number', text, start, etc)
	end

	local i = start + integer_part:len()

	--
	-- Grab an optional decimal part
	--
	local decimal_part = text:match('^%.%d+', i) or ''

	i = i + decimal_part:len()

	--
	-- Grab an optional exponential part
	--
	local exponent_part = text:match('^[eE][-+]?%d+', i) or ''

	i = i + exponent_part:len()

	local full_number_text = integer_part .. decimal_part .. exponent_part

	-- localized function to handle comma-separated decimals

	local tonumber_loc = function(str, base)
		local s = str --:gsub(",", ".") -- Assume US Locale decimal separator
		local num = tonumber(s, base)
		if (num == nil) then
			s = str:gsub('%.', ',') -- Non-US Locale decimal separator
			num = tonumber(s, base)
		end
		return num
	end

	local as_number = tonumber_loc(full_number_text)

	if not as_number then
		self:onDecodeError('bad number', text, start, etc)
	end

	return as_number, i
end

local function grok_string(self, text, start, etc)
	if text:sub(start, start) ~= '"' then
		self:onDecodeError("expected string's opening quote", text, start, etc)
	end

	local i = start + 1 -- +1 to bypass the initial quote
	local text_len = text:len()
	local VALUE = ''
	while i <= text_len do
		local c = text:sub(i, i)
		if c == '"' then
			return VALUE, i + 1
		end
		if c ~= '\\' then
			VALUE = VALUE .. c
			i = i + 1
		elseif text:match('^\\b', i) then
			VALUE = VALUE .. '\b'
			i = i + 2
		elseif text:match('^\\f', i) then
			VALUE = VALUE .. '\f'
			i = i + 2
		elseif text:match('^\\n', i) then
			VALUE = VALUE .. '\n'
			i = i + 2
		elseif text:match('^\\r', i) then
			VALUE = VALUE .. '\r'
			i = i + 2
		elseif text:match('^\\t', i) then
			VALUE = VALUE .. '\t'
			i = i + 2
		else
			local hex =
				text:match(
				'^\\u([0123456789aAbBcCdDeEfF][0123456789aAbBcCdDeEfF][0123456789aAbBcCdDeEfF][0123456789aAbBcCdDeEfF])',
				i
			)
			if hex then
				i = i + 6 -- bypass what we just read

				-- We have a Unicode codepoint. It could be standalone, or if in the proper range and
				-- followed by another in a specific range, it'll be a two-code surrogate pair.
				local codepoint = tonumber(hex, 16)
				if codepoint >= 0xD800 and codepoint <= 0xDBFF then
					-- it's a hi surrogate... see whether we have a following low
					local lo_surrogate = text:match('^\\u([dD][cdefCDEF][0123456789aAbBcCdDeEfF][0123456789aAbBcCdDeEfF])', i)
					if lo_surrogate then
						i = i + 6 -- bypass the low surrogate we just read
						codepoint = 0x2400 + (codepoint - 0xD800) * 0x400 + tonumber(lo_surrogate, 16)
					else
						-- not a proper low, so we'll just leave the first codepoint as is and spit it out.
					end
				end
				VALUE = VALUE .. unicode_codepoint_as_utf8(codepoint)
			else
				-- just pass through what's escaped
				VALUE = VALUE .. text:match('^\\(.)', i)
				i = i + 2
			end
		end
	end

	self:onDecodeError('unclosed string', text, start, etc)
end

local function skip_whitespace(text, start)
	local match_start, match_end = text:find('^[ \n\r\t]+', start) -- [http://www.ietf.org/rfc/rfc4627.txt] Section 2
	if match_end then
		return match_end + 1
	else
		return start
	end
end

local grok_one  -- assigned later

local function grok_object(self, text, start, etc)
	if not text:sub(start, start) == '{' then
		self:onDecodeError("expected '{'", text, start, etc)
	end

	local i = skip_whitespace(text, start + 1) -- +1 to skip the '{'

	local VALUE = self.strictTypes and self:newObject {} or {}

	if text:sub(i, i) == '}' then
		return VALUE, i + 1
	end
	local text_len = text:len()
	while i <= text_len do
		local key, new_i = grok_string(self, text, i, etc)

		i = skip_whitespace(text, new_i)

		if text:sub(i, i) ~= ':' then
			self:onDecodeError('expected colon', text, i, etc)
		end

		i = skip_whitespace(text, i + 1)

		local val, new_i = grok_one(self, text, i)

		VALUE[key] = val

		--
		-- Expect now either '}' to end things, or a ',' to allow us to continue.
		--
		i = skip_whitespace(text, new_i)

		local c = text:sub(i, i)

		if c == '}' then
			return VALUE, i + 1
		end

		if text:sub(i, i) ~= ',' then
			self:onDecodeError("expected comma or '}'", text, i, etc)
		end

		i = skip_whitespace(text, i + 1)
	end

	self:onDecodeError("unclosed '{'", text, start, etc)
end

local function grok_array(self, text, start, etc)
	if not text:sub(start, start) == '[' then
		self:onDecodeError("expected '['", text, start, etc)
	end

	local i = skip_whitespace(text, start + 1) -- +1 to skip the '['
	local VALUE = self.strictTypes and self:newArray {} or {}
	if text:sub(i, i) == ']' then
		return VALUE, i + 1
	end

	local text_len = text:len()
	while i <= text_len do
		local val, new_i = grok_one(self, text, i)

		table.insert(VALUE, val)

		i = skip_whitespace(text, new_i)

		--
		-- Expect now either ']' to end things, or a ',' to allow us to continue.
		--
		local c = text:sub(i, i)
		if c == ']' then
			return VALUE, i + 1
		end
		if text:sub(i, i) ~= ',' then
			self:onDecodeError("expected comma or '['", text, i, etc)
		end
		i = skip_whitespace(text, i + 1)
	end
	self:onDecodeError("unclosed '['", text, start, etc)
end

grok_one = function(self, text, start, etc)
	-- Skip any whitespace
	start = skip_whitespace(text, start)

	if start > text:len() then
		self:onDecodeError('unexpected end of string', text, nil, etc)
	end

	if text:find('^"', start) then
		return grok_string(self, text, start, etc)
	elseif text:find('^[-0123456789 ]', start) then
		return grok_number(self, text, start, etc)
	elseif text:find('^%{', start) then
		return grok_object(self, text, start, etc)
	elseif text:find('^%[', start) then
		return grok_array(self, text, start, etc)
	elseif text:find('^true', start) then
		return true, start + 4
	elseif text:find('^false', start) then
		return false, start + 5
	elseif text:find('^null', start) then
		return nil, start + 4
	else
		self:onDecodeError("can't parse JSON", text, start, etc)
	end
end

function OBJDEF:decode(text, etc)
	if type(self) ~= 'table' or self.__index ~= OBJDEF then
		OBJDEF:onDecodeError('JSON:decode must be called in method format', nil, nil, etc)
	end

	if text == nil then
		self:onDecodeOfNilError(string.format('nil passed to JSON:decode()'), nil, nil, etc)
	elseif type(text) ~= 'string' then
		self:onDecodeError(string.format('expected string argument to JSON:decode(), got %s', type(text)), nil, nil, etc)
	end

	if text:match('^%s*$') then
		return nil
	end

	if text:match('^%s*<') then
		-- Can't be JSON... we'll assume it's HTML
		self:onDecodeOfHTMLError(string.format('html passed to JSON:decode()'), text, nil, etc)
	end

	--
	-- Ensure that it's not UTF-32 or UTF-16.
	-- Those are perfectly valid encodings for JSON (as per RFC 4627 section 3),
	-- but this package can't handle them.
	--
	if text:sub(1, 1):byte() == 0 or (text:len() >= 2 and text:sub(2, 2):byte() == 0) then
		self:onDecodeError('JSON package groks only UTF-8, sorry', text, nil, etc)
	end

	local success, value = pcall(grok_one, self, text, 1, etc)
	if success then
		return value
	else
		-- should never get here... JSON parse errors should have been caught earlier
		print ('JSON decode panic:', value)
		return nil
	end
end

local function backslash_replacement_function(c)
	if c == '\n' then
		return '\\n'
	elseif c == '\r' then
		return '\\r'
	elseif c == '\t' then
		return '\\t'
	elseif c == '\b' then
		return '\\b'
	elseif c == '\f' then
		return '\\f'
	elseif c == '"' then
		return '\\"'
	elseif c == '\\' then
		return '\\\\'
	else
		return string.format('\\u%04x', c:byte())
	end
end

local chars_to_be_escaped_in_JSON_string =
	'[' ..
	'"' .. -- class sub-pattern to match a double quote
		'%\\' .. -- class sub-pattern to match a backslash
			'%z' .. -- class sub-pattern to match a null
				'\001' ..
					'-' ..
						'\031' .. -- class sub-pattern to match control characters
							']'

local function json_string_literal(value)
	local newval = value:gsub(chars_to_be_escaped_in_JSON_string, backslash_replacement_function)
	return '"' .. newval .. '"'
end

local function object_or_array(self, T, etc)
	--
	-- We need to inspect all the keys... if there are any strings, we'll convert to a JSON
	-- object. If there are only numbers, it's a JSON array.
	--
	-- If we'll be converting to a JSON object, we'll want to sort the keys so that the
	-- end result is deterministic.
	--
	local string_keys = {}
	local seen_number_key = false
	local maximum_number_key

	for key in pairs(T) do
		if type(key) == 'number' then
			seen_number_key = true
			if not maximum_number_key or maximum_number_key < key then
				maximum_number_key = key
			end
		elseif type(key) == 'string' then
			table.insert(string_keys, key)
		else
			self:onEncodeError("can't encode table with a key of type " .. type(key), etc)
		end
	end

	if seen_number_key and #string_keys > 0 then
		--
		-- Mixed key types... don't know what to do, so bail
		--
		self:onEncodeError('a table with both numeric and string keys could be an object or array; aborting', etc)
	elseif #string_keys == 0 then
		--
		-- An array
		--
		if seen_number_key then
			return nil, maximum_number_key -- an array
		else
			--
			-- An empty table...
			--
			if tostring(T) == 'JSON array' then
				return nil
			elseif tostring(T) == 'JSON object' then
				return {}
			else
				-- have to guess, so we'll pick array, since empty arrays are likely more common than empty objects
				return nil
			end
		end
	else
		--
		-- An object, so return a list of keys
		--
		table.sort(string_keys)
		return string_keys
	end
end

--
-- Encode
--
local encode_value  -- must predeclare because it calls itself
function encode_value(self, value, parents, etc)
	if value == nil then
		return 'null'
	end

	if type(value) == 'string' then
		return json_string_literal(value)
	elseif type(value) == 'number' then
		if value ~= value then
			--
			-- NaN (Not a Number).
			-- JSON has no NaN, so we have to fudge the best we can. This should really be a package option.
			--
			return 'null'
		elseif value >= math.huge then
			--
			-- Positive infinity. JSON has no INF, so we have to fudge the best we can. This should
			-- really be a package option. Note: at least with some implementations, positive infinity
			-- is both ">= math.huge" and "<= -math.huge", which makes no sense but that's how it is.
			-- Negative infinity is properly "<= -math.huge". So, we must be sure to check the ">="
			-- case first.
			--
			return '1e+9999'
		elseif value <= -math.huge then
			--
			-- Negative infinity.
			-- JSON has no INF, so we have to fudge the best we can. This should really be a package option.
			--
			return '-1e+9999'
		else
			local ret = tostring (value)
			ret = ret:gsub ('%,', '%.')
			return ret
		end
	elseif type(value) == 'boolean' then
		return tostring(value)
	elseif type(value) ~= 'table' then
		self:onEncodeError("can't convert " .. type(value) .. ' to JSON', etc)
	else
		--
		-- A table to be converted to either a JSON object or array.
		--
		local T = value

		if parents[T] then
			self:onEncodeError('table ' .. tostring(T) .. ' is a child of itself', etc)
		else
			parents[T] = true
		end

		local result_value

		local object_keys, maximum_number_key = object_or_array(self, T, etc)
		if maximum_number_key then
			--
			-- An array...
			--
			local ITEMS = {}
			for i = 1, maximum_number_key do
				table.insert(ITEMS, encode_value(self, T[i], parents, etc))
			end

			result_value = '[' .. table.concat(ITEMS, ',') .. ']'
		elseif object_keys then
			--
			-- An object
			--

			--
			-- We'll always sort the keys, so that comparisons can be made on
			-- the results, etc. The actual order is not particularly
			-- important (e.g. it doesn't matter what character set we sort
			-- as); it's only important that it be deterministic... the same
			-- every time.
			--
			local PARTS = {}
			for _, key in ipairs(object_keys) do
				local encoded_key = encode_value(self, tostring(key), parents, etc)
				local encoded_val = encode_value(self, T[key], parents, etc)
				table.insert(PARTS, string.format('%s:%s', encoded_key, encoded_val))
			end
			result_value = '{' .. table.concat(PARTS, ',') .. '}'
		else
			--
			-- An empty array/object... we'll treat it as an array, though it should really be an option
			--
			result_value = '{}'
		end

		parents[T] = false
		return result_value
	end
end

local encode_pretty_value  -- must predeclare because it calls itself
function encode_pretty_value(self, value, parents, indent, etc)
	if type(value) == 'string' then
		return json_string_literal(value)
	elseif type(value) == 'number' then
		local ret = tostring (value)
		ret = ret:gsub ('%,', '%.')
		return ret
	elseif type(value) == 'boolean' then
		return tostring(value)
	elseif type(value) == 'nil' then
		return 'null'
	elseif type(value) ~= 'table' then
		self:onEncodeError("can't convert " .. type(value) .. ' to JSON', etc)
	else
		--
		-- A table to be converted to either a JSON object or array.
		--
		local T = value

		if parents[T] then
			self:onEncodeError('table ' .. tostring(T) .. ' is a child of itself', etc)
		end
		parents[T] = true

		local result_value

		local object_keys = object_or_array(self, T, etc)
		if not object_keys then
			--
			-- An array...
			--
			local ITEMS = {}
			local subtable_indent = indent .. '  '
			local FORMAT = '%s%s'

			for i = 1, #T do

				local encoded_val = encode_pretty_value(self, T[i], parents, subtable_indent, etc)

				table.insert(ITEMS, string.format(FORMAT, subtable_indent, encoded_val))
			end

			result_value = '[\n' .. table.concat(ITEMS, ',\n') .. '\n' .. indent .. ']'
		else
			--
			-- An object -- can keys be numbers?
			--

			local KEYS = {}
			for _, key in ipairs(object_keys) do
				local encoded = encode_pretty_value(self, tostring(key), parents, '', etc)
				table.insert(KEYS, encoded)
			end
			local subtable_indent = indent .. '  '
			local FORMAT = '%s%s: %s'

			local COMBINED_PARTS = {}
			for i, key in ipairs(object_keys) do
				local encoded_val = encode_pretty_value(self, T[key], parents, subtable_indent, etc)
				table.insert(COMBINED_PARTS, string.format(FORMAT, subtable_indent, KEYS[i], encoded_val))
			end
			result_value = '{\n' .. table.concat(COMBINED_PARTS, ',\n') .. '\n' .. indent .. '}'
		end

		parents[T] = false
		return result_value
	end
end

function OBJDEF:encode(value, etc)
	if type(self) ~= 'table' or self.__index ~= OBJDEF then
		OBJDEF:onEncodeError('JSON:encode must be called in method format', etc)
	end

	local parents = {}
	return encode_value(self, value, parents, etc)
end

function OBJDEF:encode_pretty(value, etc)
	local parents = {}
	local subtable_indent = ''
	return encode_pretty_value(self, value, parents, subtable_indent, etc)
end

function OBJDEF.__tostring()
	return 'JSON encode/decode package'
end

OBJDEF.__index = OBJDEF

function OBJDEF:new(args)
	local new = {}

	if args then
		for key, val in pairs(args) do
			new[key] = val
		end
	end

	return setmetatable(new, OBJDEF)
end

return OBJDEF:new()

--
-- Version history:
--
--   20111207.5    Added support for the 'etc' arguments, for better error reporting.
--
--   20110731.4    More feedback from David Kolf on how to make the tests for Nan/Infinity system independent.
--
--   20110730.3    Incorporated feedback from David Kolf at http://lua-users.org/wiki/JsonModules:
--
--                   * When encoding lua for JSON, Sparse numeric arrays are now handled by
--                     spitting out full arrays, such that
--                        JSON:encode({"one", "two", [10] = "ten"})
--                     returns
--                        ["one","two",null,null,null,null,null,null,null,"ten"]
--
--                     In 20100810.2 and earlier, only up to the first non-null value would have been retained.
--
--                   * When encoding lua for JSON, numeric value NaN gets spit out as null, and infinity as "1+e9999".
--                     Version 20100810.2 and earlier created invalid JSON in both cases.
--
--                   * Unicode surrogate pairs are now detected when decoding JSON.
--
--   20100810.2    added some checking to ensure that an invalid Unicode character couldn't leak in to the UTF-8 encoding
--
--   20100731.1    initial public release
--
--------------------------------------------------------------------------------------------------------
-- END JSON parser
--------------------------------------------------------------------------------------------------------
 end)
package.preload['drivers-common-public.module.metrics'] = (function (...)
-- Copyright 2021 Snap One, LLC. All rights reserved.

COMMON_METRICS_VER = 7

local Metrics = {
}

DEBUG_METRICS = DEBUG_METRICS or false

function Metrics:new (group, version, identifier)

	if (group == nil) then
		group = tostring (C4:GetDriverConfigInfo ('name'))
		version = tostring (C4:GetDriverConfigInfo ('version'))

	elseif (type (group) == 'string') then
		if (type (version) == 'number') then
			version = tostring (version)
		end
		if (type (version) ~= 'string') then
			error ('Metrics:new - version is required when specifying a metric group', 2)
		end

	else
		error ('Metrics:new - group must be a string or nil', 2)
		return
	end

	if (type (identifier) ~= 'string') then
		identifier = ''
	end

	local driverName = C4:GetDriverConfigInfo ('name')
	local driverId = tostring (C4:GetDeviceID ())

	group = self:GetSafeString (group)
	version = self:GetSafeString (version)
	identifier = self:GetSafeString (identifier, true)
	driverName = self:GetSafeString (driverName)
	driverId = self:GetSafeString (driverId)

	local namespace = {
		'drivers',
		group,
		version,
		identifier,
		driverName,
		driverId,
	}

	if (not (IN_PRODUCTION)) then
		table.insert (namespace, 1, 'sandbox')
	end

	namespace = table.concat (namespace, '.')

	if (Metrics.NameSpaces and Metrics.NameSpaces [namespace]) then
		local metric = Metrics.NameSpaces [namespace]
		return metric
	end

	local metric = {
		namespace = namespace,
	}

	setmetatable (metric, self)
	self.__index = self

	Metrics.NameSpaces = Metrics.NameSpaces or {}
	Metrics.NameSpaces [namespace] = metric

	return metric
end

function Metrics:SetCounter (key, value, sampleRate)
	if (not C4.StatsdCounter) then
		return
	end

	if (type (key) ~= 'string') then
		error ('Metrics:SetCounter - key must be a string', 2)
	end

	if (value == nil) then
		value = 1
	end

	if (type (value) ~= 'number') then
		error ('Metrics:SetCounter - Cannot set counter ' .. tostring (key) ..  ' to non-number value', 2)
	end

	key = self:GetSafeString (key)

	C4:StatsdCounter (self.namespace, key, value, (sampleRate or 0))
	if (DEBUG_METRICS) then
		print ('Metrics:SetCounter:', self.namespace, key, tostring (value))
	end
end

function Metrics:SetGauge (key, value)
	if (not C4.StatsdGauge) then
		return
	end

	if (type (key) ~= 'string') then
		error ('Metrics:SetGauge - Metric key must be a string', 2)
	end

	if (type (value) ~= 'number') then
		error ('Metrics:SetGauge - Cannot set stats gauge ' .. tostring (key) ..  ' to non-number value', 2)
	end

	key = self:GetSafeString (key)

	C4:StatsdGauge (self.namespace, key, value)
	if (DEBUG_METRICS) then
		print ('Metrics:SetGauge:', self.namespace, key, tostring (value))
	end
end

function Metrics:AdjustGauge (key, value)
	if (not C4.StatsdAdjustGauge) then
		return
	end

	if (type (key) ~= 'string') then
		error ('Metrics:AdjustGauge - Metric key must be a string', 2)
	end

	if (type (value) ~= 'number') then
		error ('Metrics:AdjustGauge - Trying to adjust stats gauge ' .. tostring (key) ..  ' by non-number value', 2)
	end

	key = self:GetSafeString (key)

	C4:StatsdAdjustGauge (self.namespace, key, value)
	if (DEBUG_METRICS) then
		print ('Metrics:AdjustGauge:', self.namespace, key, tostring (value))
	end
end

function Metrics:SetTimer (key, value)
	if (not C4.StatsdTimer) then
		return
	end

	if (type (key) ~= 'string') then
		error ('Metrics:SetTimer - Metric key must be a string', 2)
	end

	if (type (value) ~= 'number') then
		error ('Metrics:SetTimer - Cannot set stats timer ' .. tostring (key) ..  ' to non-number value', 2)
	end

	key = self:GetSafeString (key)

	C4:StatsdTimer (self.namespace, key, value)
	if (DEBUG_METRICS) then
		print ('Metrics:SetTimer:', self.namespace, key, tostring (value))
	end
end

function Metrics:SetString (key, value)
	if (not C4.StatsdString) then
		return
	end

	if (type (key) ~= 'string') then
		error ('Metrics:SetString - Metric key must be a string', 2)
	end

	if (type (value) ~= 'string') then
		error ('Metrics:SetString - Cannot set stats string ' .. tostring (key) ..  ' to non-string value', 2)
	end

	key = self:GetSafeString (key)

	value = string.gsub (value, '[\r\n]+', '    ')

	C4:StatsdString (self.namespace, key, value)
	if (DEBUG_METRICS) then
		print ('Metrics:SetString:', self.namespace, key, tostring (value))
	end
end

function Metrics:SetJSON (key, value)
	if (not C4.StatsdJSONObject) then
		return
	end

	if (type (key) ~= 'string') then
		error ('Metrics:SetJSON - Metric key must be a string', 2)
	end

	if (type (value) ~= 'string') then
		error ('Metrics:SetJSON - Cannot set stats JSONObject ' .. tostring (key) ..  ' to non-string value', 2)
	end

	key = self:GetSafeString (key)

	value = string.gsub (value, '[\r\n]+', '    ')

	C4:StatsdJSONObject (self.namespace, key, value)
	if (DEBUG_METRICS) then
		print ('Metrics:SetJSON:', self.namespace, key, tostring (value))
	end
end

function Metrics:SetIncrementingMeter (key, value)
	if (not C4.StatsdIncrementMeter) then
		return
	end

	if (type (key) ~= 'string') then
		error ('Metrics:SetIncrementingMeter - Metric key must be a string', 2)
	end

	if (type (value) ~= 'number') then
		error ('Metrics:SetIncrementingMeter - Cannot set incremeting meter ' .. tostring (key) ..  ' to non-number value', 2)
		return
	end

	key = self:GetSafeString (key)

	C4:StatsdIncrementMeter (self.namespace, key, value)
	if (DEBUG_METRICS) then
		print ('Metrics:SetIncrementMeter:', self.namespace, key, tostring (value))
	end
end

function Metrics:GetSafeString (s, ignoreUselessStrings)
	if (s == nil) then
		return
	end

	s = tostring (s)
	local p = '[^%w%-%_]+'
	local safe = string.gsub (s, p, '_')

	if (ignoreUselessStrings ~= true and string.gsub (safe, '_', '') == '') then
		error ('Metrics:GetSafeString - generated a non-useful string', 3)
	end

	return safe
end

return Metrics end)
package.preload['drivers-common-public.module.ssdp'] = (function (...)
-- Copyright 2020 Control4 Corporation. All rights reserved.

COMMON_SSDP_VER = 8

require ('drivers-common-public.global.lib')
require ('drivers-common-public.global.handlers')
require ('drivers-common-public.global.timer')
require ('drivers-common-public.global.url')

local SSDP = {}

function SSDP:new (searchTarget, options)
	searchTarget = searchTarget or 'upnp:rootdevice'

	if (SSDP.SearchTargets and SSDP.SearchTargets [searchTarget]) then
		local ssdp = SSDP.SearchTargets [searchTarget]
		return ssdp
	end

	options = options or {}

	local ssdp = {
		searchTarget = searchTarget,
		devices = {},
		locations = {},
		mcIP = '239.255.255.250',
		bcIP = '255.255.255.255',
		mcOnly = options.mcOnly,
		bcOnly = options.bcOnly,
		friendlyNameTag = options.friendlyNameTag or 'friendlyName'
	}

	setmetatable (ssdp, self)
	self.__index = self

	SSDP.SearchTargets = SSDP.SearchTargets or {}
	SSDP.SearchTargets [searchTarget] = ssdp

	ssdp:setupC4Connection ()

	return ssdp
end

function SSDP:delete ()
	self:disconnect ()

	if (SSDP.SearchTargets) then
		if (self.searchTarget) then
			SSDP.SearchTargets [self.searchTarget] = nil
		end

		if (self.mcBinding) then
			OCS [self.mcBinding] = nil
			RFN [self.mcBinding] = nil
			SSDP.SearchTargets [self.mcBinding] = nil
			C4:SetBindingAddress (self.mcBinding, '')
		end

		if (self.bcBinding) then
			OCS [self.bcBinding] = nil
			RFN [self.bcBinding] = nil
			SSDP.SearchTargets [self.bcBinding] = nil
			C4:SetBindingAddress (self.bcBinding, '')
		end
	end

	return nil
end

function SSDP:StartDiscovery (resetLocations)
	self:StopDiscovery (resetLocations)

	self:connect ()

	local _timer = function (timer)
		self:connect ()
	end

	self.repeatingDiscoveryTimer = SetTimer (self.repeatingDiscoveryTimer, 5 * ONE_MINUTE, _timer, true)
end

function SSDP:StopDiscovery (resetLocations)
	if (resetLocations) then
		for location, timer in pairs (self.locations or {}) do
			self.locations [location] = CancelTimer (timer)
		end
	end

	self.repeatingDiscoveryTimer = CancelTimer (self.repeatingDiscoveryTimer)

	self:disconnect ()
end

function SSDP:SetProcessXMLFunction (f)
	local _f = function (s, uuid, data, headers)
		local success, ret = pcall (f, s, uuid, data, headers)
	end
	self.ProcessXML = _f

	return self
end

function SSDP:SetUpdateDevicesFunction (f)
	local _f = function (s, devices)
		local success, ret = pcall (f, s, devices)
	end
	self.UpdateDevices = _f

	return self
end

function SSDP:setupC4Connection ()
	local i = 6999
	if (not self.bcOnly) then
		while (not self.mcBinding and i > 6900) do
			local checkAddress = C4:GetBindingAddress (i)
			if (checkAddress == nil or checkAddress == '') then
				self.mcBinding = i
			end
			i = i - 1
		end
	end
	if (not self.mcOnly) then
		while (not self.bcBinding and i > 6900) do
			local checkAddress = C4:GetBindingAddress (i)
			if (checkAddress == nil or checkAddress == '') then
				self.bcBinding = i
			end
			i = i - 1
		end
	end

	RFN = RFN or {}
	OCS = OCS or {}

	local parseResponse = function (idBinding, nPort, strData)
		self:parseResponse (strData)
	end

	local isOnline = function (idBinding, nPort, strStatus)
		if (idBinding == self.mcBinding) then
			self.mcConnected = (strStatus == 'ONLINE')
			if (self.mcConnected) then
				self:sendDiscoveryPacket (self.mcBinding)
			end

		elseif (idBinding == self.bcBinding) then
			self.bcConnected = (strStatus == 'ONLINE')
			if (self.bcConnected) then
				self:sendDiscoveryPacket (self.bcBinding)
			end
		end
	end

	if (self.bcBinding) then
		SSDP.SearchTargets = SSDP.SearchTargets or {}
		SSDP.SearchTargets [self.bcBinding] = self

		RFN [self.bcBinding] = parseResponse
		OCS [self.bcBinding] = isOnline

		C4:CreateNetworkConnection (self.bcBinding, self.bcIP)
	end

	if (self.mcBinding) then
		SSDP.SearchTargets = SSDP.SearchTargets or {}
		SSDP.SearchTargets [self.mcBinding] = self

		RFN [self.mcBinding] = parseResponse
		OCS [self.mcBinding] = isOnline

		C4:CreateNetworkConnection (self.mcBinding, self.mcIP)
	end

	return self
end

function SSDP:connect ()
	self:disconnect ()

	if (self.mcBinding) then
		C4:NetConnect (self.mcBinding, 1900, 'UDP')
	end
	if (self.bcBinding) then
		C4:NetConnect (self.bcBinding, 1900, 'UDP')
	end
end

function SSDP:disconnect ()
	if (self.mcBinding) then
		C4:NetDisconnect (self.mcBinding, 1900, 'UDP')
	end
	if (self.bcBinding) then
		C4:NetDisconnect (self.bcBinding, 1900, 'UDP')
	end
end

function SSDP:sendDiscoveryPacket (binding)

	local ip, online

	if (binding == self.mcBinding) then
		ip = self.mcIP
		online = self.mcConnected
	elseif (binding == self.bcBinding) then
		ip = self.bcIP
		online = self.bcConnected
	end

	if (ip and online) then

		local packet = {
			'M-SEARCH * HTTP/1.1',
			'HOST: ' .. ip .. ':1900',
			'MAN: "ssdp:discover"',
			'MX: 5',
			'ST: ' .. self.searchTarget,
			'',
		}

		packet = table.concat (packet, '\r\n')

		for i = 1, 3 do
			C4:SendToNetwork (binding, 1900, packet)
		end
	end
end

function SSDP:parseResponse (data)
	local headers = {}
	for line in string.gmatch (data, '(.-)\r\n') do
		local k, v = string.match (line, '%s*(.-)%s*[:/*]%s*(.+)')
		if (k and v) then
			k = string.upper (k)
			headers [k] = v
		end
	end

	if (self.searchTarget and not (headers.ST and headers.ST == self.searchTarget)) then return end

	local alive, byebye

	if (headers.HTTP and headers.HTTP == '1.1 200 OK') then
		alive = true

	elseif (headers.NOTIFY and headers.NTS and headers.NTS == 'ssdp:alive') then
		alive = true

	elseif (headers.NOTIFY and headers.NTS and headers.NTS == 'ssdp:byebye') then
		byebye = true
	end

	if (alive) then
		local interval
		if (headers ['CACHE-CONTROL']) then
			interval = string.match (headers ['CACHE-CONTROL'], 'max-age = (%d+)')
		end
		interval = tonumber (interval) or 1800

		if (headers.LOCATION and headers.USN) then
			local location = headers.LOCATION

			local secure, server = string.match (location, 'http(s?)://(.-)/.*')

			if (not secure and server) then
				return
			end

			local ip, port

			if (server) then
				ip, port = string.match (server, '(.-):(.+)')
			end
			if (not port) then
				ip = server
				port = (secure == '' and 80) or (secure == 's' and 443) or nil
			end

			local usnUUID = string.match (headers.USN, 'uuid:(.*)')

			if (usnUUID and usnUUID == self.CurrentDeviceUUID) then
				self.rediscoverCurrentDeviceTimer = CancelTimer (self.rediscoverCurrentDeviceTimer)
			end

			if (self.devices [usnUUID] and self.devices [usnUUID].udnUUID == self.CurrentDeviceUUID) then
				self.rediscoverCurrentDeviceTimer = CancelTimer (self.rediscoverCurrentDeviceTimer)
			end

			if (usnUUID) then
				self.devices [usnUUID] = self.devices [usnUUID] or {}

				for k, v in pairs (headers) do
					self.devices [usnUUID] [k] = v
				end

				self.devices [usnUUID].IP = ip
				self.devices [usnUUID].PORT = port

				if (not self.locations [location]) then
					local contextInfo = {
						usnUUID = usnUUID,
					}
					local _callback = function (strError, responseCode, tHeaders, data, context, url)
						self:parseXML (strError, responseCode, tHeaders, data, context, url)
					end
					urlGet (location, nil, _callback, contextInfo)
				end

				local _timer = function (timer)
					self.locations [location] = nil
					for uuid, device in pairs (self.devices or {}) do
						if (device.LOCATION == location) then
							self:deviceOffline (uuid)
						end
					end
				end
				self.locations [location] = SetTimer (self.locations [location], interval * ONE_SECOND * 1.005, _timer)

				self:updateDevices ()
			end
		end

	elseif (byebye) then
		if (headers.USN) then
			local usnUUID = string.match (headers.USN, 'uuid:(.+)')
			self:deviceOffline (usnUUID)
		end
	end
end

function SSDP:deviceOffline (uuid)

	local deviceGoOfflineNow = function (device)
		local location = device.LOCATION
		self.locations [location] = CancelTimer (self.locations [location])

		self.devices [device.usnUUID] = nil
		self.devices [device.udnUUID] = nil

		if (self.CurrentDeviceUUID == device.udnUUID or self.CurrentDeviceUUID == device.usnUUID) then
			local _timer = function (timer)
				self:connect ()
			end

			self.rediscoverCurrentDeviceTimer = SetTimer (self.rediscoverCurrentDeviceTimer, 10 * ONE_SECOND, _timer, true)
		end
	end

	for _, device in pairs (self.devices or {}) do
		if (device.usnUUID == uuid or device.udnUUID == uuid) then
			deviceGoOfflineNow (device)
		end
	end

	self:updateDevices ()
end

function SSDP:updateDevices ()
	local _timer = function (timer)
		if (self.UpdateDevices and type (self.UpdateDevices == 'function')) then
			pcall (self.UpdateDevices, self, CopyTable (self.devices))
		end
	end

	self.updateDevicesTimer = SetTimer (self.updateDevicesTimer, ONE_SECOND, _timer)
end

function SSDP:parseXML (strError, responseCode, tHeaders, data, context, url)
	if (strError) then
		print ('Error retrieving device XML: ' .. (context.usnUUID or 'Unknown USN UUID') .. ' : url: ' .. url)
		return
	end

	if (responseCode == 200) then
		local udnUUID = string.match (data, '<UDN>uuid:(.-)</UDN>')

		if (udnUUID ~= context.usnUUID) then
			self.devices [udnUUID] = self.devices [context.usnUUID]
			-- If your device does this,
			-- when parsing the devices presented in updateDevices callback,
			-- check if the uuid matches the device.udnUUID before processing
		end

		local device = self.devices [udnUUID]

		local friendlyName = XMLDecode (string.match (data, '<' .. self.friendlyNameTag .. '>(.-)</' .. self.friendlyNameTag .. '>'))

		for k,v in pairs (tHeaders) do
			if (string.upper (k) == 'APPLICATION-URL') then
				local dialServer = v
				if (string.sub (dialServer, -1, -1) ~= '/') then
					dialServer = dialServer .. '/'
				end
				device.DIALSERVER = dialServer
			end
		end

		device.udnUUID = udnUUID
		device.usnUUID = context.usnUUID

		device.friendlyName = friendlyName
		device.deviceXML = data

		if (self.ProcessXML and type (self.ProcessXML == 'function')) then
			pcall (self.ProcessXML, self, context.usnUUID, data, tHeaders)
		end
		self:updateDevices ()

	end
end

return SSDP end)
package.preload['drivers-common-public.module.websocket'] = (function (...)
-- Copyright 2022 Snap One, LLC. All rights reserved.

COMMON_WEBSOCKET_VER = 7

require ('drivers-common-public.global.handlers')
require ('drivers-common-public.global.timer')

Metrics = require ('drivers-common-public.module.metrics')

local WebSocket = {}

do -- define globals
	DEBUG_WEBSOCKET = false
end

function WebSocket:new (url, additionalHeaders, wssOptions)
	if (type (additionalHeaders) ~= 'table') then
		additionalHeaders = nil
	end

	if (WebSocket.Sockets and WebSocket.Sockets [url]) then
		local ws = WebSocket.Sockets [url]
		ws.additionalHeaders = additionalHeaders
		return ws
	end

	local protocol, host, port, resource -- important values to be incorporated into our WebSocket object

	local rest, hostport -- temporary values for parsing

	protocol, rest = string.match (url or '', '(wss?)://(.*)')

	hostport, resource = string.match (rest or '', '(.-)(/.*)')
	if (not (hostport and resource)) then
		hostport = rest
		resource = '/'
	end

	host, port = string.match (hostport or '', '(.-):(.*)')

	if (not (host and port)) then
		host = hostport
		if (protocol == 'ws') then port = 80
		elseif (protocol == 'wss') then port = 443
		end
	end

	port = tonumber (port)

	if (type (wssOptions) ~= 'table') then
		wssOptions = {}
	end

	if (protocol and host and port and resource) then
		local ws = {
			url = url,
			protocol = protocol,
			host = host,
			port = port,
			resource = resource,
			buf = '',
			ping_interval = 30,
			additionalHeaders = additionalHeaders or {},
			wssOptions = wssOptions,
		}

		setmetatable (ws, self)
		self.__index = self

		ws.metrics = Metrics:new ('dcp_websocket', COMMON_WEBSOCKET_VER)

		WebSocket.Sockets = WebSocket.Sockets or {}
		WebSocket.Sockets [url] = ws

		ws.metrics:SetCounter ('Init')
		ws:setupC4Connection ()

		return ws
	else
		self.metrics:SetCounter ('Error_Init')
		return nil, 'invalid WebSocket URL provided:' .. (url or '')
	end
end

function WebSocket:delete ()
	self.deleteAfterClosing = true
	self:Close ()
	if (WebSocket.Sockets) then
		if (self.url) then
			WebSocket.Sockets [self.url] = nil
		end
		if (self.netBinding) then
			OCS [self.netBinding] = nil
			RFN [self.netBinding] = nil
			WebSocket.Sockets [self.netBinding] = nil
		end
	end

	self.metrics:SetCounter ('Delete')
	return nil
end

function WebSocket:Start ()
	print ('Starting Web Socket... Opening net connection to ' .. self.url)

	if (self.netBinding and self.protocol and self.port) then
		self.metrics:SetCounter ('Start')
		C4:NetDisconnect (self.netBinding, self.port)
		C4:NetConnect (self.netBinding, self.port)
	else
		self.metrics:SetCounter ('Error_Start')
		print ('C4 network connection not setup')
	end

	return self
end

function WebSocket:Close ()
	self.running = false
	if (self.connected) then
		local pkt = string.char (0x88, 0x82, 0x00, 0x00, 0x00, 0x00, 0x03, 0xE8)
		if (DEBUG_WEBSOCKET) then
			print ('TX CLOSE REQUEST')
		end
		self:sendToNetwork (pkt)
	end

	local _timer = function (timer)
		C4:NetDisconnect (self.netBinding, self.port)
		if (self.deleteAfterClosing) then
			self.deleteAfterClosing = nil
			C4:SetBindingAddress (self.netBinding, '')
		end
	end

	self.ClosingTimer = SetTimer (self.ClosingTimer, 3 * ONE_SECOND, _timer)

	return self
end

function WebSocket:Send (s)
	if (self.connected) then
		local len = string.len (s)
		local lenstr
		if (len <= 125) then
			lenstr = string.char (0x81, bit.bor (len, 0x80))
		elseif (len <= 65535) then
			lenstr = string.char (0x81, bit.bor (126, 0x80)) .. tohex (string.format ('%04X', len))
		else
			lenstr = string.char (0x81, bit.bor (127, 0x80)) .. tohex (string.format ('%16X', len))
		end

		local mask = {
			math.random (0, 255),
			math.random (0, 255),
			math.random (0, 255),
			math.random (0, 255),
		}

		local pkt = {
			lenstr,
			string.char (mask [1]),
			string.char (mask [2]),
			string.char (mask [3]),
			string.char (mask [4]),
		}

		table.insert (pkt, self:Mask (s, mask))

		pkt = table.concat (pkt)
		if (DEBUG_WEBSOCKET) then
			local d = {'', 'TX'}

			table.insert (d, '')
			table.insert (d, s)
			table.insert (d, '')

			d = table.concat (d, '\r\n')

			print (d)
		end
		self:sendToNetwork (pkt)
	end

	return self
end

function WebSocket:SetProcessMessageFunction (f)
	local _f = function (websocket, data)
		local success, ret = pcall (f, websocket, data)
		if (success == false) then
			self.metrics:SetCounter ('Error_ProcessMessageCallback')
			print ('Websocket callback ProcessMessage error: ', ret, data)
		end
	end
	self.ProcessMessage = _f

	return self
end

function WebSocket:SetClosedByRemoteFunction (f)
	local _f = function (websocket)
		local success, ret = pcall (f, websocket)
		if (success == false) then
			self.metrics:SetCounter ('Error_ClosedByRemoteCallback')
			print ('Websocket callback ClosedByRemote error: ', ret, data)
		end
	end
	self.ClosedByRemote = _f

	return self
end

function WebSocket:SetEstablishedFunction (f)
	local _f = function (websocket)
		local success, ret = pcall (f, websocket)
		if (success == false) then
			self.metrics:SetCounter ('Error_EstablishedCallback')
			print ('Websocket callback Established error: ', ret, data)
		end
	end
	self.Established = _f

	return self
end

function WebSocket:SetOfflineFunction (f)
	local _f = function (websocket)
		local success, ret = pcall (f, websocket)
		if (success == false) then
			self.metrics:SetCounter ('Error_OfflineCallback')
			print ('Websocket callback Offline error: ', ret, data)
		end
	end
	self.Offline = _f

	return self
end

-- Functions below this line should not be called directly by users of this library

function WebSocket:setupC4Connection ()
	local i = 6100
	while (not self.netBinding and i < 6200) do
		local checkAddress = C4:GetBindingAddress (i)
		if (checkAddress == nil or checkAddress == '') then
			self.netBinding = i
		end
		i = i + 1
	end

	if (self.netBinding and self.protocol) then
		WebSocket.Sockets = WebSocket.Sockets or {}
		WebSocket.Sockets [self.netBinding] = self

		if (self.protocol == 'wss') then
			C4:CreateNetworkConnection (self.netBinding, self.host, 'SSL')
			C4:NetPortOptions (self.netBinding, self.port, 'SSL', self.wssOptions)
		else
			C4:CreateNetworkConnection (self.netBinding, self.host)
		end

		OCS = OCS or {}
		OCS [self.netBinding] = function (idBinding, nPort, strStatus)
			self:ConnectionChanged (strStatus)
		end

		RFN = RFN or {}
		RFN [self.netBinding] = function (idBinding, nPort, strData)
			self:ParsePacket (strData)
		end
	else
		self.metrics:SetCounter ('Error_NoNetBinding')
	end
	return self
end

function WebSocket:MakeHeaders ()
	self.key = ''
	for i = 1, 16 do
		self.key = self.key .. string.char (math.random (33, 125))
	end
	self.key = C4:Base64Encode (self.key)

	local headers = {
		'GET ' .. self.resource .. ' HTTP/1.1',
		'Host: ' .. self.host .. ':' .. self.port,
		'Cache-Control: no-cache',
		'Pragma: no-cache',
		'Connection: Upgrade',
		'Upgrade: websocket',
		'Sec-WebSocket-Key: ' .. self.key,
		'Sec-WebSocket-Version: 13',
		'User-Agent: C4WebSocket/' .. COMMON_WEBSOCKET_VER,
	}

	for _, header in ipairs (self.additionalHeaders or {}) do
		table.insert (headers, header)
	end

	table.insert (headers, '\r\n')

	headers = table.concat (headers, '\r\n')

	return headers
end

function WebSocket:ParsePacket (strData)
	self.buf = (self.buf or '') .. strData

	if (self.running) then
		self:parseWSPacket ()
	else
		self:parseHTTPPacket ()
	end
end

function WebSocket:parseWSPacket ()
	local _, h1, h2, b1, b2, b3, b4, b5, b6, b7, b8 = string.unpack (self.buf, 'bbbbbbbbbb')

	local final = (bit.band (h1, 0x80) == 0x80)
	local rsv1 = (bit.band (h1, 0x40) == 0x40)
	local rsv2 = (bit.band (h1, 0x20) == 0x20)
	local rsv3 = (bit.band (h1, 0x10) == 0x10)
	local opcode = bit.band (h1, 0x0F)

	local masked = (bit.band (h2, 0x80) == 0x80)
	local mask
	local len = bit.band (h2, 0x7F)

	local msglen = 0
	local headerlen = 2
	if (len <= 125) then
		-- 1-byte length
		msglen = len
	elseif (len == 126) then
		-- 2-byte length
		msglen = msglen + b1; msglen = msglen * 0x100
		msglen = msglen + b2;
		headerlen = 4
	elseif (len == 127) then
		-- 8-byte length
		msglen = msglen + b1; msglen = msglen * 0x100
		msglen = msglen + b2; msglen = msglen * 0x100
		msglen = msglen + b3; msglen = msglen * 0x100
		msglen = msglen + b4; msglen = msglen * 0x100
		msglen = msglen + b5; msglen = msglen * 0x100
		msglen = msglen + b6; msglen = msglen * 0x100
		msglen = msglen + b7; msglen = msglen * 0x100
		msglen = msglen + b8;
		headerlen = 10
	end

	if (masked) then
		local maskbytes = string.sub (self.buf, headerlen + 1, headerlen + 5)
		mask = {}
		for i = 1, 4 do
			mask [i] = string.byte (string.sub (maskbytes, i, i))
		end
		headerlen = headerlen + 4
	end

	if (string.len (self.buf) >= headerlen + msglen) then
		local thisFragment = string.sub (self.buf, headerlen + 1, headerlen + msglen)
		if (masked) then
			if (mask) then
				thisFragment = self:Mask (thisFragment, mask)
			else
				self.metrics:SetCounter ('Error_NoMaskReceived')
				print ('masked bit set but no mask received')
				self.buf = ''
				return
			end
		end
		self.buf = string.sub (self.buf, headerlen + msglen + 1)

		if (opcode == 0x08) then
			self.metrics:SetCounter ('ClosedByRemote')
			if (DEBUG_WEBSOCKET) then
				print ('RX CLOSE REQUEST')
			end
			if (self.ClosedByRemote) then
				self:ClosedByRemote ()
			end

		elseif (opcode == 0x09) then -- ping control frame
			if (DEBUG_WEBSOCKET) then
				print ('RX PING')
			end
			self:Pong ()

		elseif (opcode == 0x0A) then -- pong control frame
			if (DEBUG_WEBSOCKET) then
				print ('RX PONG')
			end

		elseif (opcode == 0x00) then -- continuation frame
			if (not self.fragment) then
				self.metrics:SetCounter ('Error_FramesOutOfOrder')
				print ('error: received continuation frame before start frame')
				self.buf = ''
				return
			end
			self.fragment = self.fragment .. thisFragment

		elseif (opcode == 0x01 or opcode == 0x02) then -- non-control frame, beginning of fragment
			self.fragment = thisFragment
		end

		if (final and opcode < 0x08) then
			local data = self.fragment
			self.fragment = nil

			if (DEBUG_WEBSOCKET) then
				local d = {'', 'RX'}

				table.insert (d, '')
				table.insert (d, data)
				table.insert (d, '')

				d = table.concat (d, '\r\n')

				print (d)
			end

			if (self.ProcessMessage) then
				self:ProcessMessage (data)
			end
		end

		if (string.len (self.buf) > 0) then
			self:ParsePacket ('')
		end
	end
end

function WebSocket:parseHTTPPacket ()
	local headers = {}
	for line in string.gmatch (self.buf, '(.-)\r\n') do
		local k, v = string.match (line, '%s*(.-)%s*[:/*]%s*(.+)')
		if (k and v) then
			k = string.upper (k)
			headers [k] = v
		end
	end

	local EOH = string.find (self.buf, '\r\n\r\n')

	if (EOH and headers ['SEC-WEBSOCKET-ACCEPT']) then
		self.buf = string.sub (self.buf, EOH + 4)
		local check = self.key .. '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'
		local hash = C4:Hash ('sha1', check, {['return_encoding'] = 'BASE64'})

		if (headers ['SEC-WEBSOCKET-ACCEPT'] == hash and
			headers ['UPGRADE'] == 'websocket' and
			string.lower (headers ['CONNECTION']) == 'upgrade') then

			self.running = true
			self.metrics:SetCounter ('Running')
			if (self.Established) then
				self:Established ()
			end
		end
	end
end

function WebSocket:Ping ()
	if (self.connected) then
		-- MASK of 0x00's
		local pkt = string.char (0x89, 0x80, 0x00, 0x00, 0x00, 0x00)
		if (DEBUG_WEBSOCKET) then
			print ('TX PING')
		end
	self:sendToNetwork (pkt)
	end
end

function WebSocket:Pong ()
	if (self.connected) then
		local pkt = string.char (0x8A, 0x80, 0x00, 0x00, 0x00, 0x00)
		if (DEBUG_WEBSOCKET) then
			print ('TX PONG')
		end
		self:sendToNetwork (pkt)
	end
end

function WebSocket:ConnectionChanged (strStatus)
	self.connected = (strStatus == 'ONLINE')
	if (self.PingTimer) then self.PingTimer = self.PingTimer:Cancel () end
	if (self.connected) then
		local pkt = self:MakeHeaders ()
		self:sendToNetwork (pkt)

		local _timer = function (timer)
			self:Ping ()
		end
		self.PingTimer = SetTimer (self.PingTimer, self.ping_interval * ONE_SECOND, _timer, true)
		self.metrics:SetCounter ('Connected')
		print ('WS ' .. self.url .. ' connected')
	else
		if (self.running) then
			self.metrics:SetCounter ('DisconnectedWhileRunning')
			print ('WS ' .. self.url .. ' disconnected while running')
		else
			self.metrics:SetCounter ('DisconnectedWhileNotRunning')
			print ('WS ' .. self.url .. ' disconnected while not running')
		end
		self.running = false
		if (self.Offline) then
			self:Offline ()
		end
	end
end

function WebSocket:sendToNetwork (packet)
	C4:SendToNetwork (self.netBinding, self.port, packet)
end

function WebSocket:Mask (s, mask)
	if (type (mask) == 'table') then
	elseif (type (mask) == 'string' and string.len (mask) >= 4) then
		local m = {}
		for i = 1, string.len (mask) do
			table.insert (m, string.byte (mask [i]))
		end
		mask = m
	end

	local slen = string.len (s)
	local mlen = #mask

	local packet = {}

	for i = 1, slen do
		local pos = i % mlen
		if (pos == 0) then pos = mlen end
		local maskbyte = mask [pos]
		local sbyte = string.sub (s, i, i)
		local byte = string.byte (sbyte)
		local char = string.char (bit.bxor (byte, maskbyte))
		table.insert (packet, char)
	end

	packet = table.concat (packet)
	return (packet)
end

return WebSocket end)
-- driver.lua

require ('drivers-common-public.global.lib')
require ('drivers-common-public.global.timer')
require ('drivers-common-public.global.url')
JSON = require ('drivers-common-public.module.json')

g_UpdateTimer = nil

function dbg(message)
    if (Properties['Debug Mode'] == 'On') then
        print('Weather: ' .. tostring(message))
    end
end

function OnDriverLateInit()
    if (not (Variables and Variables.TODAY_HIGH)) then C4:AddVariable("TODAY_HIGH", "0", "NUMBER", true, false) end
    if (not (Variables and Variables.TODAY_LOW)) then C4:AddVariable("TODAY_LOW", "0", "NUMBER", true, false) end
    if (not (Variables and Variables.FEELS_LIKE_HIGH)) then C4:AddVariable("FEELS_LIKE_HIGH", "0", "NUMBER", true, false) end
    if (not (Variables and Variables.FEELS_LIKE_LOW)) then C4:AddVariable("FEELS_LIKE_LOW", "0", "NUMBER", true, false) end
    if (not (Variables and Variables.RAIN_CHANCE)) then C4:AddVariable("RAIN_CHANCE", "0", "NUMBER", true, false) end
    if (not (Variables and Variables.RAIN_TOTAL)) then C4:AddVariable("RAIN_TOTAL", "0", "NUMBER", true, false) end
    if (not (Variables and Variables.RAIN_HOURS)) then C4:AddVariable("RAIN_HOURS", "0", "NUMBER", true, false) end
    if (not (Variables and Variables.MAX_WIND)) then C4:AddVariable("MAX_WIND", "0", "NUMBER", true, false) end
    if (not (Variables and Variables.UV_INDEX)) then C4:AddVariable("UV_INDEX", "0", "NUMBER", true, false) end
    if (not (Variables and Variables.LAST_UPDATE)) then C4:AddVariable("LAST_UPDATE", "Never", "STRING", true, false) end


    for property, _ in pairs(Properties) do
        OnPropertyChanged(property)
    end

    StartUpdateTimer()
    FetchWeather()
end

function OnPropertyChanged(strProperty)
    if (strProperty == 'Debug Mode') then
        if (Properties['Debug Mode'] == 'On') then print("Weather: Debug Mode Enabled") end
    elseif (strProperty == 'Update Interval (minutes)') then
        StartUpdateTimer()
    elseif (strProperty == 'Latitude' or strProperty == 'Longitude' or strProperty == 'Temperature Unit') then
        FetchWeather()
    end
end

function StartUpdateTimer()
    if g_UpdateTimer then 
        g_UpdateTimer:Cancel()
        g_UpdateTimer = nil
    end
    
    local intervalMinutes = tonumber(Properties["Update Interval (minutes)"]) or 60
    if intervalMinutes < 15 then intervalMinutes = 15 end
    local intervalMs = intervalMinutes * 60 * 1000
    
    g_UpdateTimer = C4:SetTimer(intervalMs, function() FetchWeather() end, true)
end

function FetchWeather()
    local lat = Properties["Latitude"]
    local lon = Properties["Longitude"]
    
    if (lat == "" or lon == "") then
        dbg("Missing Latitude or Longitude")
        return
    end
    
    local tempUnitProp = Properties["Temperature Unit"] or "Fahrenheit"
    local unitParam = "fahrenheit"
    local windUnit = "mph"
    local precipUnit = "inch"
    
    if tempUnitProp == "Celsius" then
        unitParam = "celsius"
        windUnit = "kmh"
        precipUnit = "mm"
    end
    

    local dailyParams = "temperature_2m_max,temperature_2m_min," ..
                        "apparent_temperature_max,apparent_temperature_min," ..
                        "precipitation_probability_max,precipitation_sum,precipitation_hours," ..
                        "wind_speed_10m_max,uv_index_max"

    local url = "https://api.open-meteo.com/v1/forecast?latitude=" .. lat .. 
                "&longitude=" .. lon .. 
                "&daily=" .. dailyParams .. 
                "&temperature_unit=" .. unitParam .. 
                "&wind_speed_unit=" .. windUnit .. 
                "&precipitation_unit=" .. precipUnit .. 
                "&timezone=auto&forecast_days=1"
    
    dbg("Fetching: " .. url)
    
    local options = { fail_on_error = false }
    urlGet(url, {}, CheckResponse, {}, options)
end

function CheckResponse(strError, responseCode, tHeaders, data, context, url)
    if (strError) then
        dbg("Network Error: " .. strError)
        C4:FireEvent("Update Failed") 
        return
    end

    if (responseCode ~= 200) then
        dbg("HTTP Error Code: " .. tostring(responseCode))
        C4:FireEvent("Update Failed")
        return
    end

    local tData = data
    if (type(data) == "string") then
        tData = JSON:decode(data)
    end
    
    if (tData and tData.daily) then
        local d = tData.daily
        local timeStr = os.date("%Y-%m-%d %H:%M:%S")
        
        local function round(num) return math.floor(num + 0.5) end
        
        local high = round(d.temperature_2m_max[1])
        local low = round(d.temperature_2m_min[1])
        local feelsHigh = round(d.apparent_temperature_max[1])
        local feelsLow = round(d.apparent_temperature_min[1])
        
        local rainChance = d.precipitation_probability_max[1]
        local rainTotal = d.precipitation_sum[1]
        local rainHrs = d.precipitation_hours[1]
        local wind = d.wind_speed_10m_max[1]
        local uv = d.uv_index_max[1]

        local distLabel = (Properties["Temperature Unit"] == "Celsius") and " km/h" or " mph"
        local rainLabel = (Properties["Temperature Unit"] == "Celsius") and " mm" or " in"

        C4:UpdateProperty("Last Update:", timeStr)
        C4:UpdateProperty("Today High:", high .. "")
        C4:UpdateProperty("Today Low:", low .. "")
        C4:UpdateProperty("Feels Like High:", feelsHigh .. "")
        C4:UpdateProperty("Feels Like Low:", feelsLow .. "")
        
        C4:UpdateProperty("Rain Chance:", rainChance .. "%")
        C4:UpdateProperty("Rain Total:", rainTotal .. rainLabel)
        C4:UpdateProperty("Rain Hours:", rainHrs .. " hrs")
        C4:UpdateProperty("Max Wind:", wind .. distLabel)
        C4:UpdateProperty("UV Index:", uv)

   
        C4:SetVariable("LAST_UPDATE", timeStr)
        C4:SetVariable("TODAY_HIGH", high)
        C4:SetVariable("TODAY_LOW", low)
        C4:SetVariable("FEELS_LIKE_HIGH", feelsHigh)
        C4:SetVariable("FEELS_LIKE_LOW", feelsLow)
        C4:SetVariable("RAIN_CHANCE", rainChance)
        C4:SetVariable("RAIN_TOTAL", rainTotal)
        C4:SetVariable("RAIN_HOURS", rainHrs)
        C4:SetVariable("MAX_WIND", wind)
        C4:SetVariable("UV_INDEX", uv)

        dbg("Weather Updated Successfully")
        C4:FireEvent("Weather Updated")
    else
        dbg("JSON Decoding Failed or Invalid Structure")
        C4:FireEvent("Update Failed")
    end
end

function ExecuteCommand(strCommand, tParams)
    if strCommand == "REFRESH_WEATHER" then 
        FetchWeather() 
    end
end

function OnDriverDestroyed()
    if g_UpdateTimer then
        g_UpdateTimer:Cancel()
        g_UpdateTimer = nil
    end
end